{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DocumentAccessPOC","text":"<p>A proof-of-concept secure document management system that solves the critical challenge of granular access control in organizational environments where traditional permission systems fall short.</p> <p> </p>"},{"location":"#problem-statement","title":"\ud83d\udea9 Problem Statement","text":"<p>In modern organizations, controlling document access is complex and fraught with security risks. Traditional approaches like Role-Based Access Control (RBAC), file system permissions, and Access Control Lists (ACLs) struggle with:</p> <ul> <li>Overly Broad Access: Developers and DevOps teams often have administrative access to everything, undermining confidentiality.</li> <li>Lack of Granularity: Difficulty controlling access based on multiple dimensions (e.g., Teams, Projects, and Organization Levels).</li> <li>Document Duplication: Sharing documents often requires creating multiple copies with different permissions, leading to versioning chaos.</li> <li>Scalability Issues: Managing permissions becomes unmanageable as users and documents grow.</li> <li>Security Vulnerabilities: System administrators can access sensitive content regardless of intended restrictions.</li> </ul>"},{"location":"#solution-overview","title":"\ud83d\udca1 Solution Overview","text":"<p>This project introduces a secure system where each document is encrypted with a unique key. Access is then managed through a central SharedKeyRegistry, which grants permissions on a per-user, per-document basis without ever exposing the document's content to the server.</p> <p>\u2705 Zero-Trust for Data at Rest: Even system administrators cannot access document content without authorization. \u2705 Granular Control Architecture: The database schema is built for fine-grained permissions (see Roadmap). \u2705 No Duplication: A single encrypted document is stored, with access managed dynamically. \u2705 Scalable by Design: Efficiently manage permissions for thousands of users and documents. \u2705 Secure Collaboration: Multiple users can work on the same secure document version.</p>"},{"location":"#project-genesis-solving-a-real-world-challenge","title":"\ud83c\udf31 Project Genesis: Solving a Real-World Challenge","text":"<p>This project wasn't born from a theoretical exercise; it was created to solve a critical, real-world security gap encountered in modern software development.</p> <p>The journey began while a colleague was building an internal project management tool. The tool required a document storage system where teams (like Finance or HR) could upload highly sensitive files. The core problem was this: how can you guarantee that sensitive documents are inaccessible even to the DevOps and Cloud Admins who manage the infrastructure? With direct access to storage backends like AWS S3, traditional permissions are easily bypassed.</p> <p>While concepts like using a Document Encryption Key (DEK) were known, existing systems didn't offer a clear solution for the most complex part: managing access for multiple, specific users in a zero-trust way.</p> <p>The breakthrough came from tackling that multi-user challenge from first principles: 1.  A single, encrypted document should exist, avoiding duplication. 2.  To grant access, its unique DEK must be shared securely. 3.  Instead of sharing the DEK directly, it could be encrypted separately for each authorized user using their individual public key. 4.  A central registry could then map which users have access to which documents by storing these individually-encrypted DEKs.</p> <p>This design elegantly solved the problem. Sharing a document with a new user becomes a lightweight operation of encrypting the DEK one more time, and revocation is as simple as deleting an entry\u2014all without the server ever needing to see the plaintext keys.</p> <p>Only after its conception was it clear that this independently-derived architecture aligns perfectly with robust industry best practices. It's a powerful implementation of what is known as envelope encryption combined with a dynamic key registry for cryptographic access control. This PoC serves as a blueprint for developers facing the same dilemma, demonstrating a practical path to building truly secure systems.</p>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User Client  \u2502      \u2502   FastAPI Server   \u2502      \u2502  Storage Backend  \u2502\n\u2502               \u2502\u25c4\u2500\u2500\u2500\u2500\u25ba\u2502                    \u2502\u25c4\u2500\u2500\u2500\u2500\u25ba\u2502 (e.g., Local, S3) \u2502\n\u2502  \u2022 JWT Token  \u2502      \u2502  \u2022 API Endpoints   \u2502      \u2502                   \u2502\n\u2502               \u2502      \u2502  \u2022 JWT Validation  \u2502      \u2502  \u2022 Encrypted      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502  \u2022 Access Logic    \u2502      \u2502    Documents      \u2502\n                       \u2502  \u2022 Crypto Ops      \u2502      \u2502                   \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n                                  \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502       Database        \u2502\n                      \u2502                       \u2502\n                      \u2502  \u2022 Users              \u2502\n                      \u2502  \u2022 Documents          \u2502\n                      \u2502  \u2022 Public Keys        \u2502\n                      \u2502  \u2022 SharedKeyRegistry  \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#api-reference","title":"\ud83d\udcda API Reference","text":""},{"location":"#authentication","title":"Authentication","text":"<ul> <li><code>POST /users</code>: Create a new user account.</li> <li><code>POST /token</code>: Authenticate and get a JWT token.</li> </ul>"},{"location":"#users","title":"Users","text":"<ul> <li><code>GET /users/me</code>: Get the profile of the currently authenticated user.</li> <li><code>GET /users</code>: Get public profiles of users by their IDs.</li> </ul>"},{"location":"#documents","title":"Documents","text":"<ul> <li><code>POST /documents</code>: Upload, encrypt, and share a new document.</li> <li><code>GET /documents</code>: List all documents accessible to the current user.</li> <li><code>GET /documents/{doc_id}</code>: Download and decrypt a document.</li> <li><code>PUT /documents/{doc_id}/share</code>: Share a document with more users.</li> <li><code>PUT /documents/{doc_id}/revoke</code>: Revoke user access from a document.</li> <li><code>DELETE /documents/{doc_id}</code>: Securely delete a document.</li> </ul>"},{"location":"#positioning-in-the-security-landscape","title":"\ud83c\udd9a Positioning in the Security Landscape","text":"<p>When solving a fundamental problem like secure data access, it's common for independent efforts to converge on similar architectural patterns. After developing this PoC, a review of the landscape shows that the core principles used here\u2014like envelope encryption and cryptographic access control\u2014are industry best practices, validating the soundness of the approach.</p> <p>However, the focus and purpose of this project are fundamentally different from existing commercial applications. This PoC is not intended to be a feature-complete alternative to a platform like Tresorit or Nextcloud. Instead, its unique value lies in being a:</p> <p>Developer-centric, unopinionated, and self-hostable backend blueprint.</p> <p>The following comparison clarifies this distinction, showing how this project fills a specific niche for developers who need to build secure document functionality into their own applications, rather than adopting a monolithic, all-in-one platform.</p> Feature / Aspect DocumentAccessPOC (This PoC) Commercial SaaS (e.g., Tresorit) Open-Source Platform (e.g., Nextcloud) Security Model \u2705 Zero-Trust \u2705 Zero-Knowledge \u2705 (With E2EE Module) Deployment Model Self-Hosted API Managed SaaS Self-Hosted App Granular Control \u2705 (Architectural) \u2705 (Full UI) \u2705 (Full UI) Cryptographic Revocation \u26a0\ufe0f Partial (No Key Rotation) \u2705 Complete \u26a0\ufe0f Partial / Complex Client-Side Keys \u26a0\ufe0f Server-Side (In-Memory) \u2705 Yes \u2705 Yes Focus Secure Backend/API End-User Application Full Collaboration Platform <p>Key Takeaway: This PoC serves as a foundational secure backend. Its purpose is to provide a clear, working model of the core cryptographic and access control logic that developers can learn from, adapt, and integrate into their own products.</p>"},{"location":"#poc-scope-production-considerations","title":"\u26a0\ufe0f PoC Scope &amp; Production Considerations","text":"<p>This project is a Proof-of-Concept designed to demonstrate a secure architectural pattern. The following table outlines key production-level features that were intentionally scoped out to maintain a tight focus on the core backend logic. It details the current PoC's behavior, the ideal production approach, and the rationale behind each scoping decision.</p> Area / Feature Current PoC Implementation Production-Ready Approach Scoping Rationale for PoC Cryptographic Revocation Removes user's key from the registry, preventing future API access. Key Rotation: Re-encrypt the document with a new key and distribute it to remaining users. This is a complex and computationally expensive workflow, outside the core goal of demonstrating the primary access and sharing mechanism. Private Key Handling Private key is briefly decrypted in server memory during authentication. Client-Side Cryptography: All private key operations occur on the client (browser/app), achieving a full zero-knowledge architecture. This requires a dedicated frontend application with crypto libraries. The PoC's focus was on the backend API that such a client would consume. Account Recovery None. A lost passphrase results in permanent data inaccessibility. User-Managed Recovery Key: A one-time key is generated during onboarding that the user must save to restore access if their passphrase is lost. This is an application-layer user flow, separate from the core cryptographic backend this PoC aims to demonstrate. Collaboration &amp; Compliance No document versioning or audit trails are implemented. Dedicated Subsystems: A robust versioning engine to prevent data loss and a tamper-resistant audit log for security and compliance. These are both major subsystems. Implementing them would have detracted from the PoC's primary goal of proving the core zero-trust access model."},{"location":"#project-structure","title":"\ud83d\uddc2\ufe0f Project Structure","text":"<pre><code>DocumentAccessPOC/\n\u251c\u2500\u2500 main.py                 # FastAPI application entry point\n\u251c\u2500\u2500 requirements.txt        # Python dependencies\n\u251c\u2500\u2500 config.py               # Configuration settings (DB, JWT, Storage)\n\u251c\u2500\u2500 models/                 # Data models and schemas (SQLModel)\n\u251c\u2500\u2500 helpers/                # Cryptographic utilities (AES, RSA, JWT)\n\u251c\u2500\u2500 backends/               # Storage and database backend abstractions\n\u251c\u2500\u2500 logic/                  # Business logic and dependencies\n\u2514\u2500\u2500 docs/                   # Additional documentation\n</code></pre>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>Thanks to the FastAPI team and the contributors to the PyCryptodome and Cryptography libraries for their excellent tools.</p>"},{"location":"#a-note-on-passphrase-generation","title":"A Note on Passphrase Generation","text":"<p>The unique, one-time passphrases in this project are generated using a custom library, BetterPassphrase, also created by me. It's designed to create secure, memorable passphrases from grammatically correct phrases.</p> <p>Key Features of BetterPassphrase:</p> <ul> <li>Secure &amp; Memorable: Generates grammatically correct phrases that are easier to remember than random strings.</li> <li>Security Focused: Includes entropy calculations to balance memorability with cryptographic strength.</li> <li>Highly Customizable: Control word count, separators, capitalization, and more.</li> <li>Powerful CLI: A full command-line interface for batch generation and file output.</li> </ul> <p>You can check it out on PyPI or explore the source code on GitHub.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This is a Proof-of-Concept project and is not currently available under a formal open-source license. It is intended for demonstration and educational purposes.</p>"},{"location":"extensibility/","title":"Ease of Extensibility","text":"<p>The chosen approach, combining encryption-based access control with a SharedKeyRegistry, is designed for flexibility and extensibility. Here's how it simplifies scenarios like granting some users edit access while others have read-only access:</p>"},{"location":"extensibility/#1-dynamic-role-assignment-in-the-sharedkeyregistry","title":"1. Dynamic Role Assignment in the SharedKeyRegistry","text":""},{"location":"extensibility/#how-it-works","title":"How it Works","text":"<p>The SharedKeyRegistry maps users to documents and specifies their access level (e.g., Read, Edit, Share). For example:</p> DocumentID UserID AccessLevel Doc123 UserA Read Doc123 UserB Edit Doc123 UserC Read"},{"location":"extensibility/#extensibility","title":"Extensibility","text":"<p>To modify permissions, you simply update the user's <code>AccessLevel</code> in the registry. No need to duplicate documents or re-encrypt files for each permission change.</p> <p>Example: If UserC needs Edit access, you update their entry to <code>Edit</code>. This avoids document duplication or re-encryption.</p>"},{"location":"extensibility/#2-granular-access-control","title":"2. Granular Access Control","text":""},{"location":"extensibility/#read-vs-edit","title":"Read vs. Edit","text":"<ul> <li>Read Access: A user's private key allows decryption of the document for viewing.</li> <li>Edit Access: The system could additionally store a \"Write Key\" in the registry for users with edit permissions. Only users with Edit access can modify the document, re-encrypt it, and update the registry with the new encryption key.</li> </ul>"},{"location":"extensibility/#share-access","title":"Share Access","text":"<p>Users with Share permissions can grant other users access by updating the SharedKeyRegistry (if the owner allows delegation).</p>"},{"location":"extensibility/#3-minimal-effort-to-scale-to-new-use-cases","title":"3. Minimal Effort to Scale to New Use Cases","text":""},{"location":"extensibility/#adding-new-roles","title":"Adding New Roles","text":"<p>If a new access level (e.g., \"Comment\") needs to be introduced, it's straightforward to extend the <code>AccessLevel</code> enum in the database and update the system's logic to handle the new role.</p>"},{"location":"extensibility/#example-scenario","title":"Example Scenario","text":"<p>Add a \"Comment\" role: Users with this access can decrypt the document but cannot modify it. The system can enforce this by disallowing re-encryption for these users.</p>"},{"location":"extensibility/#supporting-multiple-teamsprojects","title":"Supporting Multiple Teams/Projects","text":"<p>The registry can easily associate documents with teams or projects, granting shared access without creating duplicate entries.</p>"},{"location":"extensibility/#4-key-revocation-and-propagation","title":"4. Key Revocation and Propagation","text":"<ul> <li> <p>Revoking Edit Access:   When a user loses Edit access, their permissions are updated in the registry. The document owner can optionally rotate the encryption key to ensure past access cannot be exploited (e.g., if the user cached the decryption key).</p> </li> <li> <p>Granting New Access:   Adding a new user with specific permissions simply requires adding an entry in the registry and sharing the Document Encryption Key (DEK) encrypted with their public key.</p> </li> </ul>"},{"location":"extensibility/#5-built-in-security-for-multiple-access-levels","title":"5. Built-In Security for Multiple Access Levels","text":"<p>The encryption-based model ensures users can only perform actions permitted by their role: - Read Access: Users can only decrypt the content. - Edit Access: Users can decrypt, modify, and re-encrypt content (if authorized). - Owner Access: The owner has full control to share, revoke, or delete documents.</p> <p>By enforcing these access levels at the cryptographic level, the system remains secure while allowing flexibility in permission updates.</p>"},{"location":"extensibility/#benefits-of-extensibility","title":"Benefits of Extensibility","text":"<ol> <li> <p>No Document Duplication:    You don\u2019t need multiple copies for different access levels\u2014permissions are tied to the registry and encryption keys.</p> </li> <li> <p>Scalability:    Adding or removing users and adjusting their permissions is lightweight and doesn\u2019t require document reprocessing.</p> </li> <li> <p>Granularity:    The model supports fine-grained access control without making the system overly complex.</p> </li> <li> <p>Future-Proof:    New access roles (e.g., \"Comment\" or \"View History\") or more complex team structures can be added without disrupting the existing system.</p> </li> </ol> <p>In summary, the design allows seamless addition or modification of access levels while maintaining robust security, avoiding duplication, and ensuring smooth collaboration.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Q: Can system administrators access document content? A: No. Documents are encrypted at rest with keys that only authorized users can decrypt. Admins can manage the system but cannot read the content.</p> <p>Q: What happens if a user forgets their permanent password? A: By design, their encrypted private key is irrecoverable. Access to their previously shared documents is lost. A new user profile would need to be created.</p> <p>Q: What encryption algorithms are used? A: AES-128-GCM for document encryption (by default), RSA-2048 for secure key exchange, and SHA-256 for hashing. The user's passphrase is also hashed before being used to derive an encryption key.</p>"},{"location":"features/","title":"Key Features","text":""},{"location":"features/#end-to-end-encryption","title":"\ud83d\udd12 End-to-End Encryption","text":"<ul> <li>Documents are encrypted with a unique Document Encryption Key (DEK) using AES-GCM.</li> <li>DEKs are securely exchanged using RSA public key cryptography.</li> <li>Each user's private key is encrypted with a unique, strong passphrase.</li> </ul>"},{"location":"features/#granular-access-control-architectural","title":"\ud83c\udfaf Granular Access Control (Architectural)","text":"<p>The database schema is designed to support permissions based on: -   Teams: e.g., DevOps, Finance, HR -   Projects: e.g., P1, P2, P3 -   Roles: e.g., Lead, Admin, Member (Note: API endpoints for managing teams and projects are on the roadmap.)</p>"},{"location":"features/#secure-operations","title":"\ud83d\ude80 Secure Operations","text":"<ul> <li>Upload: Automatic encryption and access control setup.</li> <li>Share: Dynamically grant access to other users without re-uploading.</li> <li>Revoke: Instantly revoke access for any shared user.</li> <li>Delete: Securely delete a document and all its associated keys.</li> </ul>"},{"location":"features/#advanced-security","title":"\ud83d\udd10 Advanced Security","text":"<ul> <li>JWT-based Stateless Authentication: Secure and scalable authentication flow.</li> <li>SharedKeyRegistry: Centralized, cryptographically-enforced permission management.</li> <li>No Passphrases over the Wire: User passphrases are used only once to obtain a short-lived JWT, never for individual operations.</li> </ul>"},{"location":"flow/","title":"API Flow","text":""},{"location":"flow/#flow-diagram","title":"Flow Diagram","text":"<pre><code>---\nconfig:\n  look: classic # handDrawn\n  layout: elk # dagre\n\n---\nflowchart TD\n    %% User Node\n    U[\"User\"]\n\n    %% User Creation\n    subgraph User_Creation\n        UC1[\"POST /users (user details, ID)\"] --&gt; UC2[\"Generate passphrase &amp; RSA key pair (private and public key)\"]\n        UC2 --&gt; UC3[\"Encrypt the private key with passphrase using AES-GCM\"]\n        UC3 --&gt; UC4[\"Save user details, public key, encrypted private key in Database\"]\n        UC4 --&gt; UC5[\"Return the User details along with passphrase\"]\n    end\n\n    %% Token Generation\n    subgraph Token_Generation\n        TG1[\"POST /token (userid, passphrase)\"] --&gt; TG2[\"Verify user and passphrase\"]\n        TG2 --&gt; TG3[\"Generate JWT token\"]\n        TG3 --&gt; TG4[\"Return JWT token\"]\n    end\n\n    %% Document Upload\n    subgraph Document_Upload\n        DU1[\"POST /documents (file, passphrase, user IDs, token)\"] --&gt; DU2[\"Verify JWT token\"]\n        DU2 --&gt; DU3[\"Verify user with passphrase\"]\n        DU3 --&gt; DU4[\"Generate the Document ID using the file content hash + user ID + filename\"]\n        DU4 --&gt; DU5[\"Check if document exists in Database\"]\n        DU5 --&gt;|Exists| DU6[\"Update SharedKeyRegistry with new user IDs\"]\n        DU5 --&gt;|Doesn't Exist| DU7[\"Generate DEK (random AES key)\"]\n        DU7 --&gt; DU8[\"Encrypt file content and upload to Storage Backend\"]\n        DU8 --&gt; DU9[\"Save Document object in Database\"]\n        DU9 --&gt; DU6\n        DU6 --&gt; DU10[\"Save SharedKeyRegistry entries\"]\n        DU10 --&gt; DU11[\"Return the Document object\"]\n    end\n\n    %% Document Sharing\n    subgraph Document_Sharing\n        DS1[\"PUT /documents/{doc_id}/share (passphrase, user IDs, token)\"] --&gt; DS2[\"Verify JWT token\"]\n        DS2 --&gt; DS3[\"Verify ownership\"]\n        DS3 --&gt;|Owner Verified| DS4[\"Encrypt DEK with new users' public keys\"]\n        DS4 --&gt; DS5[\"Update SharedKeyRegistry with new entries\"]\n        DS3 --&gt;|Unauthorized| DS6[\"Error: Unauthorized\"]\n    end\n\n    %% Document Retrieval\n    subgraph Document_Retrieval\n        DR1[\"GET /documents/{doc_id} (passphrase, token)\"] --&gt; DR2[\"Verify JWT token\"]\n        DR2 --&gt; DR3[\"Fetch user's encrypted private key\"]\n        DR3 --&gt; DR4[\"Decrypt private key using passphrase\"]\n        DR4 --&gt; DR5[\"Check SharedKeyRegistry for user_id and doc_id\"]\n        DR5 --&gt;|Entry Found| DR6[\"Decrypt shared key (DEK) using private key\"]\n        DR6 --&gt; DR7[\"Fetch encrypted document from Storage Backend\"]\n        DR7 --&gt; DR8[\"Decrypt document using DEK\"]\n        DR8 --&gt; DR9[\"Return decrypted file content\"]\n        DR5 --&gt;|Entry Not Found| DR10[\"Error: Access Denied\"]\n    end\n\n    %% Access Revocation\n    subgraph Access_Revocation\n        AR1[\"PUT /documents/{doc_id}/revoke (passphrase, user IDs, token)\"] --&gt; AR2[\"Verify JWT token\"]\n        AR2 --&gt; AR3[\"Verify ownership\"]\n        AR3 --&gt;|Owner Verified| AR4[\"Remove user IDs from SharedKeyRegistry\"]\n        AR3 --&gt;|Unauthorized| AR5[\"Error: Unauthorized\"]\n    end\n\n    %% Document Deletion\n    subgraph Document_Deletion\n        DD1[\"DELETE /documents/{doc_id} (passphrase, token)\"] --&gt; DD2[\"Verify JWT token\"]\n        DD2 --&gt; DD3[\"Verify ownership\"]\n        DD3 --&gt;|Owner Verified| DD4[\"Remove Document object from Database\"]\n        DD4 --&gt; DD5[\"Remove entries from SharedKeyRegistry\"]\n        DD5 --&gt; DD6[\"Delete file from Storage Backend\"]\n        DD3 --&gt;|Unauthorized| DD7[\"Error: Unauthorized\"]\n    end\n\n    %% Connections to User\n    U --&gt; UC1 &amp; TG1\n    TG4 --&gt; DU1\n    TG4 --&gt; DS1\n    TG4 --&gt; DR1\n    TG4 --&gt; AR1\n    TG4 --&gt; DD1</code></pre>"},{"location":"flow/#flow-overview","title":"Flow Overview:","text":"<p>This flow diagram represents the interactions within the Document Management and Sharing API, including user creation, document upload, sharing, retrieval, access revocation, deletion, and token-based authentication.</p> <ol> <li> <p>User Creation:</p> <ul> <li>A user is created via the <code>POST /users</code> route, where their basic details and ID are submitted.</li> <li>The system generates a passphrase, RSA key pair, and encrypts the private key using AES-GCM.</li> <li>The public key, encrypted private key, and other user details are saved in the database, and the user receives the necessary information, including the passphrase.</li> </ul> </li> <li> <p>Token Generation:</p> <ul> <li>The <code>POST /token</code> endpoint is used to authenticate the user by verifying their <code>userid</code> and <code>passphrase</code>.</li> <li>If valid, a JWT token is generated and returned, which will be used in future requests for authentication.</li> </ul> </li> <li> <p>Document Upload:</p> <ul> <li>A user can upload a document using the <code>POST /documents</code> endpoint, where the document file, passphrase, and IDs of users with whom the document should be shared are provided.</li> <li>The system verifies the JWT token, checks the user\u2019s passphrase, and generates a Document ID based on the file content.</li> <li>If the document already exists, it updates the sharing registry; otherwise, a new document is created, encrypted with a unique Document Encryption Key (DEK), and stored.</li> <li>The DEK is then encrypted with the public keys of the users to share the document securely.</li> </ul> </li> <li> <p>Document Sharing:</p> <ul> <li>The <code>PUT /documents/{doc_id}/share</code> endpoint allows the owner of a document to share it with additional users.</li> <li>The system verifies the JWT token and ownership before encrypting the DEK with the public keys of the new users and updating the SharedKeyRegistry.</li> </ul> </li> <li> <p>Document Retrieval:</p> <ul> <li>Users can retrieve documents via the <code>GET /documents/{doc_id}</code> endpoint by providing their passphrase and JWT token.</li> <li>The system verifies the user\u2019s token, decrypts their private key using the passphrase, and checks the SharedKeyRegistry for the document's access.</li> <li>If access is granted, the encrypted document is fetched from the storage backend, decrypted using the DEK, and returned.</li> </ul> </li> <li> <p>Access Revocation:</p> <ul> <li>The owner can revoke access to a document using the <code>PUT /documents/{doc_id}/revoke</code> endpoint.</li> <li>The system verifies the owner\u2019s JWT token and removes the revoked user IDs from the SharedKeyRegistry.</li> </ul> </li> <li> <p>Document Deletion:</p> <ul> <li>The owner can delete a document using the <code>DELETE /documents/{doc_id}</code> endpoint.</li> <li>The system verifies ownership and removes the document from the database, deletes entries from the SharedKeyRegistry, and removes the document from the storage backend.</li> </ul> </li> </ol>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>An SQL Database (defaults to SQLite)</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/subhayu99/DocumentAccessPOC\ncd DocumentAccessPOC\n\n# Set up virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"quick-start/#configuration","title":"Configuration","text":"<ol> <li>Database: The system defaults to a SQLite database in <code>./data/db.sqlite</code>. You can configure <code>DATABASE_URL</code> in <code>config.py</code> for PostgreSQL or other databases.</li> <li>JWT Secret: Change the <code>JWT_SECRET_KEY</code> in <code>config.py</code> for production use.</li> </ol>"},{"location":"quick-start/#running-the-application","title":"Running the Application","text":"<p><pre><code># Start the server\nuvicorn main:app --reload --port 8000\n</code></pre> The API will be available at <code>http://localhost:8000</code>, with interactive docs at <code>http://localhost:8000/docs</code>.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The architecture of this PoC was designed from the ground up for extensibility. The use of a <code>SharedKeyRegistry</code> and the existing database schema (which includes models for Teams and Projects) provides a strong foundation for building a production-grade service.</p>"},{"location":"roadmap/#architectural-extensibility","title":"Architectural Extensibility","text":"<p>The current design makes it straightforward to add more sophisticated features without a major overhaul:</p> <ul> <li>Granular Roles: New access levels (e.g., \"Editor,\" \"Commenter,\" \"Viewer\") can be added by simply extending the <code>SharedKeyRegistry</code> with a <code>role</code> column. The API logic can then enforce permissions based on this role.</li> <li>Group-Based Permissions: The groundwork is already laid for team- and project-based sharing. Building API endpoints to manage these groups and link them to documents is a logical next step.</li> <li>Attribute-Based Access: In the future, the model could even be extended to support attribute-based access control (ABAC), where permissions are granted based on user attributes (e.g., \"only users from the 'Finance' department in 'Europe' can access\").</li> </ul>"},{"location":"roadmap/#roadmap_1","title":"Roadmap","text":"<p>The path from this PoC to a full-featured, production-ready system can be broken down into clear phases. This roadmap directly addresses the limitations outlined in the section above.</p>"},{"location":"roadmap/#phase-1-foundational-backend-completed-in-this-poc","title":"Phase 1: Foundational Backend (\u2705 Completed in this PoC)","text":"<ul> <li> Core cryptographic engine using AES-GCM and RSA.</li> <li> Secure, per-user, per-document access control model.</li> <li> Stateless JWT-based authentication.</li> <li> Basic CRUD operations for users and documents.</li> </ul>"},{"location":"roadmap/#phase-2-hardening-for-production-backend","title":"Phase 2: Hardening for Production Backend","text":"<p>This phase focuses on making the backend robust, secure, and ready for integration.</p> <ul> <li> Implement Key Rotation: Introduce a mechanism to re-encrypt documents for true cryptographic revocation when a user's access is removed.</li> <li> Comprehensive Audit Logging: Create a tamper-resistant audit trail for all security-sensitive events (logins, shares, access, deletions).</li> <li> Document Versioning: Build a system to manage document version history, preventing data loss in collaborative environments.</li> <li> Team &amp; Project Management: Implement the API endpoints to create, manage, and assign users to teams and projects, enabling group-based sharing.</li> </ul>"},{"location":"roadmap/#phase-3-building-the-full-application-ecosystem","title":"Phase 3: Building the Full Application Ecosystem","text":"<p>This phase focuses on building the user-facing components and enterprise-grade features.</p> <ul> <li> Client-Side Crypto &amp; UI: Develop a frontend application (web, desktop, or mobile) that performs all private key operations locally. This achieves a full zero-knowledge architecture and is the most critical step for a production system.</li> <li> User-Friendly Account Recovery: Implement a secure workflow for users to back up and use a one-time Recovery Key.</li> <li> SSO / LDAP Integration: Allow users to authenticate using existing enterprise identity providers.</li> <li> Advanced Sharing Controls: Add features like expiring links, password-protected public shares, and read-only access.</li> </ul>"},{"location":"security/","title":"Security Model","text":"<p>The security of this system is built on a robust cryptographic flow that ensures data confidentiality and enforces access control at every step. Even with full database and server access, an unauthorized party cannot read document content.</p>"},{"location":"security/#cryptographic-flow","title":"Cryptographic Flow","text":"<p>Here is a breakdown of the key cryptographic operations.</p> <p>??? info \"1. User Creation &amp; Key Generation</p> <p>When a new user is created, the server generates their cryptographic identity. The user's private key is immediately encrypted with a strong, unique passphrase that is returned to the user only once.\"     <pre><code>graph TD\n    subgraph Server-Side Process\n        A[Start: User Registration Request] --&gt; B(Generate RSA-2048 Key Pair);\n        B --&gt; C{Public Key &amp; Private Key};\n        A --&gt; D(Generate Secure Passphrase);\n        C --&gt; F(Encrypt Private Key with Hashed Passphrase);\n        D --&gt; F;\n        C --&gt; G[Store Public Key in DB];\n        F --&gt; H[Store Encrypted Private Key in DB];\n    end\n\n    subgraph Response to User\n        I[Return User Profile &amp; One-Time Passphrase];\n    end\n\n    H --&gt; I;</code></pre></p> <p>??? info \"2. User Authentication</p> <p>The user's passphrase is never stored on the server. It is used only once during the login process to unlock a short-lived JWT, which is then used for all subsequent authenticated requests.\"     <pre><code>sequenceDiagram\n    participant User\n    participant API Server\n\n    User-&gt;&gt;API Server: POST /token (username, passphrase)\n    activate API Server\n    API Server-&gt;&gt;API Server: Hash provided passphrase\n    API Server-&gt;&gt;API Server: Attempt to decrypt user's private key in-memory\n    alt Credentials are valid\n        API Server-&gt;&gt;API Server: Generate short-lived JWT\n        API Server--&gt;&gt;User: Return JWT Token\n    else Credentials are invalid\n        API Server--&gt;&gt;User: Return 401 Unauthorized\n    end\n    deactivate API Server</code></pre></p> <p>??? info \"3. Document Upload &amp; Encryption</p> <p>When a document is uploaded, it is encrypted with a brand new, single-use key (DEK). This DEK is then encrypted for the owner and each designated recipient using their respective public keys.\"     <pre><code>graph TD\n    subgraph Client\n        A[User uploads file and list of recipients]\n    end\n\n    subgraph Server\n        B(Generate unique Document Encryption Key - DEK)\n        C(Encrypt Document with DEK using AES-GCM)\n        D{\"For each recipient (including owner)...\"}\n        E(Fetch Recipient's Public Key from DB)\n        F(Encrypt DEK with Recipient's Public Key)\n        G[Store Encrypted DEK in SharedKeyRegistry]\n    end\n\n    subgraph Storage\n        H((Store Encrypted Document))\n    end\n\n    A --&gt; B;\n    B --&gt; C;\n    C --&gt; H;\n    A --&gt; D;\n    D --&gt; E;\n    E --&gt; F;\n    F --&gt; G;</code></pre></p> <p>??? info \"4. Document Access &amp; Decryption</p> <p>To access a document, the server uses the user's credentials (from the JWT) to decrypt their private key in memory, which is then used to decrypt the document's specific DEK. This DEK is finally used to decrypt the document itself, which is streamed back to the user.\"     <pre><code>sequenceDiagram\n    participant User\n    participant API Server\n    participant Database\n    participant Storage\n\n    User-&gt;&gt;API Server: GET /documents/{doc_id} (with JWT)\n    activate API Server\n    API Server-&gt;&gt;API Server: 1. Validate JWT &amp; get User ID\n\n    API Server-&gt;&gt;Database: 2. Fetch User's Encrypted Private Key\n    Database--&gt;&gt;API Server: Returns Encrypted Private Key\n\n    note right of API Server: User's passphrase was used at login to create a key for this decryption, held in memory.\n    API Server-&gt;&gt;API Server: 3. Decrypt User's Private Key in-memory\n\n    API Server-&gt;&gt;Database: 4. Fetch the Encrypted DEK for this User &amp; Document\n    Database--&gt;&gt;API Server: Returns Encrypted DEK\n\n    API Server-&gt;&gt;API Server: 5. Decrypt DEK with User's Private Key\n\n    API Server-&gt;&gt;Storage: 6. Fetch Encrypted Document\n    Storage--&gt;&gt;API Server: Returns Encrypted Document\n\n    API Server-&gt;&gt;API Server: 7. Decrypt Document with DEK\n\n    API Server--&gt;&gt;User: 8. Stream decrypted document content\n    deactivate API Server</code></pre></p>"},{"location":"security/#access-control-matrix","title":"Access Control Matrix","text":"Role Upload Share Revoke Delete Read Own Read Shared Owner \u2705 \u2705 \u2705 \u2705 \u2705 N/A Shared User \u274c \u274c \u274c \u274c \u2705 \u2705"},{"location":"security/#security-guarantees","title":"Security Guarantees","text":"<ul> <li>Confidentiality: Documents at rest are unreadable without authorization, even to system admins.</li> <li>Access Control: Permissions are enforced cryptographically, not just via application logic.</li> <li>No Passphrase in Transit: After initial login, only short-lived JWTs are transmitted.</li> </ul>"},{"location":"solution/","title":"Document Sharing Solution","text":""},{"location":"solution/#problem-statement","title":"Problem Statement","text":"<p>The challenge was to build an internal application where users could upload documents and control who can access them. The main complexity was ensuring that access could be finely controlled based on Teams (e.g., DevOps, Finance, HR), Projects (e.g., p1, p2), and Organization Levels (e.g., CEO, CTO, Cashier). Furthermore, developers and DevOps had access to everything, potentially undermining the confidentiality of sensitive documents. The solution needed to ensure that users had granular control over who could view, edit, and share documents while maintaining security, especially when some internal users had high-level access.</p>"},{"location":"solution/#alternative-strategies","title":"Alternative Strategies","text":"<p>Several alternative strategies could have been employed to solve this problem, including:</p>"},{"location":"solution/#1-basic-role-based-access-control-rbac","title":"1. Basic Role-Based Access Control (RBAC)","text":"<p>How it Works: Users are assigned specific roles (e.g., Admin, Manager, Employee), and each role is granted predefined permissions (e.g., Admin can access all documents, Manager can access department-level documents, Employee can only access their own documents).</p> <p>Problems: </p> <ul> <li>Lack of Granularity: RBAC doesn\u2019t easily accommodate scenarios where permissions need to vary based on Teams, Projects, or Organization Levels. For example, it\u2019s challenging to limit access to \"HR documents related to Project X.\"  </li> <li>Overly Broad Access: Roles like Admin or Developer might inherently have access to everything, which undermines confidentiality for sensitive documents.  </li> <li>Difficult to Adapt: As teams or projects change, or as new organizational levels are added, the roles and their associated permissions need frequent updates, leading to increased maintenance overhead.  </li> </ul>"},{"location":"solution/#2-file-system-permissions","title":"2. File System Permissions","text":"<p>How it Works: Document access is managed directly by the file system or storage backend, where each file has permissions set for read, write, and execute operations based on users or groups.</p> <p>Problems: </p> <ul> <li>Scalability Issues: Managing file-level permissions becomes unmanageable as the number of users and documents grows. Every new document or user addition requires manual adjustments.  </li> <li>No Team-Based Logic: File systems don\u2019t inherently understand organizational structures like Teams or Projects, making it hard to enforce hierarchical or team-specific permissions.  </li> <li>Duplication for Sharing: Sharing a document often requires duplicating it into a different location with separate permissions, leading to storage inefficiency and version control problems (e.g., conflicting edits or outdated copies).  </li> </ul>"},{"location":"solution/#3-access-control-lists-acls","title":"3. Access Control Lists (ACLs)","text":"<p>How it Works: Each document is associated with a list of users and their specific permissions (e.g., User A: Read, User B: Write/Delete).</p> <p>Problems: </p> <ul> <li>Frequent Updates: In dynamic environments, ACLs require constant updates whenever a team member joins, leaves, or changes roles, which is error-prone.  </li> <li>Complexity in Management: Managing ACLs for thousands of documents and users becomes unwieldy, especially when users belong to multiple teams or projects.  </li> <li>Duplication for Sharing: If the same document needs to be shared with different permissions across multiple teams, duplication may again be necessary to handle separate ACLs, creating inefficiencies and inconsistencies.  </li> </ul>"},{"location":"solution/#4-encryption-based-access-control","title":"4. Encryption-Based Access Control","text":"<p>How it Works: Documents are encrypted, and access is controlled by sharing encryption keys with authorized users. Public key cryptography (e.g., RSA) is often used to secure the keys.</p> <p>Problems: </p> <ul> <li>Key Management Complexity: Sharing, storing, and revoking encryption keys is non-trivial. Mistakes in key handling can compromise security or lead to access issues.  </li> <li>Collaboration Challenges: If multiple users need write access to a document, managing and updating the encryption keys for every change can become cumbersome.  </li> <li>Duplication for Sharing: To share a document with a different set of users, a new encryption key may need to be generated and the document re-encrypted, leading to potential duplication of encrypted versions.  </li> </ul>"},{"location":"solution/#document-duplication-a-critical-pain-point","title":"Document Duplication: A Critical Pain Point","text":"<p>Duplication of documents is a recurring challenge across these alternatives:</p> <ol> <li>Storage Overhead: If multiple versions of a document exist due to sharing or team-specific modifications, storage usage can balloon unnecessarily.  </li> <li>Version Control Issues: Different versions can lead to confusion, especially if changes are made to one version but not propagated to others.  </li> <li>Security Risk: If older or duplicate versions aren\u2019t properly deleted, they may become a vulnerability, allowing unauthorized access.  </li> </ol>"},{"location":"solution/#chosen-implementation-why-its-better","title":"Chosen Implementation &amp; Why It's Better","text":"<p>The solution adopted is a combination of encryption-based access control with a SharedKeyRegistry, token-based authentication (JWT), and public key cryptography. Here's why this approach stands out:</p> <ol> <li> <p>Granular Control Through SharedKeyRegistry:    The core of this solution is the SharedKeyRegistry, a centralized database that tracks which users have access to which documents. This allows for fine-grained control, based on Teams, Projects, and Organization Levels. Unlike RBAC or ACLs, the SharedKeyRegistry is flexible and allows easy modification of access rights for any given document, making it scalable as new teams, projects, or roles are added.</p> </li> <li> <p>Secure Document Encryption Using AES &amp; RSA:    Documents are encrypted using a Document Encryption Key (DEK), which is encrypted using the recipient\u2019s public RSA key. This ensures that only authorized users (those with the corresponding private key) can decrypt and access the document. This method provides high security without requiring users to have direct access to sensitive encryption keys.</p> </li> <li> <p>JWT for Authentication and Stateless Authorization: JWT tokens are used for authentication, ensuring that only users with valid tokens can interact with the system. This eliminates the need for session management on the server and scales easily. The tokens are passed along with each request, and the system verifies the JWT for every protected API call, ensuring that no unauthorized access is granted.</p> </li> <li> <p>Passphrase-Protected Private Keys:    By protecting the user\u2019s private key with a passphrase, an extra layer of security is added. Even if an attacker gains access to the private key, they would still need the passphrase to decrypt it. This reduces the risk of key exposure.</p> </li> <li> <p>Ownership and Access Revocation:    The solution includes mechanisms for document sharing, revocation, and deletion. Owners of the document can add or remove access for specific users at any time, making it highly flexible. Revocation ensures that if a user should no longer have access (e.g., an employee leaves the company), they are immediately denied access to all documents they were previously authorized to access.</p> </li> <li> <p>Avoidance of Duplication: </p> </li> <li>Centralized Access via the SharedKeyRegistry: A single encrypted document is stored. The SharedKeyRegistry dynamically manages access, removing the need for duplicate copies.  </li> <li>Dynamic Sharing and Revocation: Owners can modify access rights without creating new versions of the document.  </li> <li> <p>Efficient Collaboration: All users work on the same encrypted document while maintaining security.  </p> </li> <li> <p>Scalability and Flexibility:    The architecture is designed to scale as the number of users, documents, and teams grows. JWT tokens make authentication lightweight and scalable, while the SharedKeyRegistry allows for easy modification of document access rights without having to update complex permissions for each user or document.  </p> </li> </ol>"},{"location":"solution/#summary-of-benefits","title":"Summary of Benefits","text":"<ul> <li>Security: Document content is encrypted, and access is controlled using public key cryptography and secure tokens, ensuring that unauthorized users cannot view the documents.  </li> <li>Granular Access Control: The SharedKeyRegistry allows for precise control over who can access each document, based on teams, projects, and organizational levels.  </li> <li>Scalability: The use of JWT tokens and the SharedKeyRegistry enables the system to scale without sacrificing performance.  </li> <li>User Control: Document owners can add or revoke access at any time, and sensitive documents are automatically protected using encryption.  </li> </ul> <p>This implementation is far more flexible, scalable, and secure than basic RBAC, ACLs, or file system permissions, and it avoids the risks of overly broad access permissions while providing the necessary functionality to manage document access effectively across different teams and projects.</p>"},{"location":"solution/#flow-diagram","title":"Flow Diagram","text":"<p>Here you can find the API flow diagram (with a brief overview): API Flow</p>"},{"location":"usage/","title":"Usage Examples","text":"<p>Note</p> <p>The user's <code>parmanent_password</code> (passphrase) is only used to get a JWT. All subsequent requests are authenticated using the token in the <code>Authorization</code> header.</p>"},{"location":"usage/#1-user-registration-authentication","title":"1. User Registration &amp; Authentication","text":"<pre><code># Create a new user (Note: id can be any unique string, e.g., username)\ncurl -X POST \"http://localhost:8000/users\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n       \"id\": \"alice\",\n       \"name\": \"Alice\",\n       \"email\": \"alice@example.com\",\n       \"designation\": \"Engineer\"\n     }'\n\n# Response includes the one-time permanent password. Save it!\n# {\n#   \"id\": \"alice\",\n#   \"name\": \"Alice\",\n#   ...\n#   \"parmanent_password\": \"some-generated-secure-passphrase\",\n# }\n\n# Get an authentication token using the user's ID and permanent password\ncurl -X POST \"http://localhost:8000/token\" \\\n     -H \"Content-Type: application/x-www-form-urlencoded\" \\\n     -d \"username=alice&amp;password=some-generated-secure-passphrase\"\n</code></pre>"},{"location":"usage/#2-document-operations","title":"2. Document Operations","text":"<pre><code># Set your JWT for convenience\nTOKEN=\"your-jwt-token-here\"\n\n# Upload and share a document with 'bob' and 'charlie'\ncurl -X POST \"http://localhost:8000/documents?share_with=bob&amp;share_with=charlie\" \\\n     -H \"Authorization: Bearer $TOKEN\" \\\n     -F \"file=@./report.pdf\"\n\n# Share an existing document with 'david'\ncurl -X PUT \"http://localhost:8000/documents/{doc_id}/share?share_with=david\" \\\n     -H \"Authorization: Bearer $TOKEN\"\n\n# Download a document you have access to\ncurl -X GET \"http://localhost:8000/documents/{doc_id}\" \\\n     -H \"Authorization: Bearer $TOKEN\" \\\n     --output downloaded_report.pdf\n\n# Revoke access for 'bob'\ncurl -X PUT \"http://localhost:8000/documents/{doc_id}/revoke?revoke=bob\" \\\n     -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":""},{"location":"api/backends/#backendsdbabstractdb","title":"backends.db.abstractdb","text":""},{"location":"api/backends/#backends.db.abstractdb","title":"<code>backends.db.abstractdb</code>","text":""},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase","title":"<code>AbstractDatabase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for database operations.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>class AbstractDatabase(ABC):\n    \"\"\"Abstract base class for database operations.\"\"\"\n\n    @abstractmethod\n    def connect(self):\n        \"\"\"Establish a connection to the database.\"\"\"\n        pass\n\n    @abstractmethod\n    def execute_query(self, query: str, params: tuple = ()):\n        \"\"\"Execute a query against the database.\"\"\"\n        pass\n\n    @abstractmethod\n    def fetch_one(self):\n        \"\"\"Fetch one record from the executed query.\"\"\"\n        pass\n\n    @abstractmethod\n    def fetch_all(self):\n        \"\"\"Fetch all records from the executed query.\"\"\"\n        pass\n\n    @abstractmethod\n    def close(self):\n        \"\"\"Close the database connection.\"\"\"\n        pass\n\n    def __enter__(self):\n        \"\"\"Enter the runtime context for this database connection.\"\"\"\n        self.connect()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Exit the runtime context and close the database connection.\"\"\"\n        self.close()\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for this database connection.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>def __enter__(self):\n    \"\"\"Enter the runtime context for this database connection.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context and close the database connection.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Exit the runtime context and close the database connection.\"\"\"\n    self.close()\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.close","title":"<code>close()</code>  <code>abstractmethod</code>","text":"<p>Close the database connection.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>@abstractmethod\ndef close(self):\n    \"\"\"Close the database connection.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Establish a connection to the database.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>@abstractmethod\ndef connect(self):\n    \"\"\"Establish a connection to the database.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.execute_query","title":"<code>execute_query(query, params=())</code>  <code>abstractmethod</code>","text":"<p>Execute a query against the database.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>@abstractmethod\ndef execute_query(self, query: str, params: tuple = ()):\n    \"\"\"Execute a query against the database.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.fetch_all","title":"<code>fetch_all()</code>  <code>abstractmethod</code>","text":"<p>Fetch all records from the executed query.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>@abstractmethod\ndef fetch_all(self):\n    \"\"\"Fetch all records from the executed query.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.db.abstractdb.AbstractDatabase.fetch_one","title":"<code>fetch_one()</code>  <code>abstractmethod</code>","text":"<p>Fetch one record from the executed query.</p> Source code in <code>backends/db/abstractdb.py</code> <pre><code>@abstractmethod\ndef fetch_one(self):\n    \"\"\"Fetch one record from the executed query.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backendsdbazsqldb","title":"backends.db.azsqldb","text":""},{"location":"api/backends/#backends.db.azsqldb","title":"<code>backends.db.azsqldb</code>","text":""},{"location":"api/backends/#backends.db.azsqldb.AzureSQLDatabase","title":"<code>AzureSQLDatabase</code>","text":"<p>               Bases: <code>AbstractDatabase</code></p> <p>Azure SQL Database implementation of the DatabaseInterface.</p> Source code in <code>backends/db/azsqldb.py</code> <pre><code>class AzureSQLDatabase(AbstractDatabase):\n    \"\"\"Azure SQL Database implementation of the DatabaseInterface.\"\"\"\n\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.connection = None\n        self.cursor = None\n\n    def connect(self):\n        self.connection = pyodbc.connect(self.connection_string)\n        self.cursor = self.connection.cursor()\n\n    def execute_query(self, query: str, params: tuple = ()):\n        if not self.connection:\n            raise ConnectionError(\"Database not connected.\")\n        self.cursor.execute(query, params)\n\n    def fetch_one(self):\n        return self.cursor.fetchone()\n\n    def fetch_all(self):\n        return self.cursor.fetchall()\n\n    def close(self):\n        if self.cursor:\n            self.cursor.close()\n        if self.connection:\n            self.connection.close()\n</code></pre>"},{"location":"api/backends/#backendsdbsqlitedb","title":"backends.db.sqlitedb","text":""},{"location":"api/backends/#backends.db.sqlitedb","title":"<code>backends.db.sqlitedb</code>","text":""},{"location":"api/backends/#backends.db.sqlitedb.SQLiteDatabase","title":"<code>SQLiteDatabase</code>","text":"<p>               Bases: <code>AbstractDatabase</code></p> <p>SQLite implementation of the DatabaseInterface.</p> Source code in <code>backends/db/sqlitedb.py</code> <pre><code>class SQLiteDatabase(AbstractDatabase):\n    \"\"\"SQLite implementation of the DatabaseInterface.\"\"\"\n\n    def __init__(self, db_path: str):\n        self.db_path = db_path\n        self.connection = None\n        self.cursor = None\n\n    def connect(self):\n        self.connection = sqlite3.connect(self.db_path)\n        self.cursor = self.connection.cursor()\n\n    def execute_query(self, query: str, params: tuple = ()):\n        if not self.connection:\n            raise ConnectionError(\"Database not connected.\")\n        self.cursor.execute(query, params)\n\n    def fetch_one(self):\n        return self.cursor.fetchone()\n\n    def fetch_all(self):\n        return self.cursor.fetchall()\n\n    def close(self):\n        if self.cursor:\n            self.cursor.close()\n        if self.connection:\n            self.connection.close()\n</code></pre>"},{"location":"api/backends/#backendsfilesystemabstractfs","title":"backends.filesystem.abstractfs","text":""},{"location":"api/backends/#backends.filesystem.abstractfs","title":"<code>backends.filesystem.abstractfs</code>","text":""},{"location":"api/backends/#backends.filesystem.abstractfs.AbstractFileSystem","title":"<code>AbstractFileSystem</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file system operations.</p> Source code in <code>backends/filesystem/abstractfs.py</code> <pre><code>class AbstractFileSystem(ABC):\n    \"\"\"Abstract base class for file system operations.\"\"\"\n\n    @abstractmethod\n    def read(self, relative_path: str):\n        \"\"\"Read data from the file.\"\"\"\n        pass\n\n    @abstractmethod\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to the file.\"\"\"\n        pass\n\n    @abstractmethod\n    def list(self, relative_dir: str):\n        \"\"\"List files in the specified directory.\"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, relative_path: str):\n        \"\"\"Delete the file.\"\"\"\n        pass\n</code></pre>"},{"location":"api/backends/#backends.filesystem.abstractfs.AbstractFileSystem.delete","title":"<code>delete(relative_path)</code>  <code>abstractmethod</code>","text":"<p>Delete the file.</p> Source code in <code>backends/filesystem/abstractfs.py</code> <pre><code>@abstractmethod\ndef delete(self, relative_path: str):\n    \"\"\"Delete the file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.filesystem.abstractfs.AbstractFileSystem.list","title":"<code>list(relative_dir)</code>  <code>abstractmethod</code>","text":"<p>List files in the specified directory.</p> Source code in <code>backends/filesystem/abstractfs.py</code> <pre><code>@abstractmethod\ndef list(self, relative_dir: str):\n    \"\"\"List files in the specified directory.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.filesystem.abstractfs.AbstractFileSystem.read","title":"<code>read(relative_path)</code>  <code>abstractmethod</code>","text":"<p>Read data from the file.</p> Source code in <code>backends/filesystem/abstractfs.py</code> <pre><code>@abstractmethod\ndef read(self, relative_path: str):\n    \"\"\"Read data from the file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.filesystem.abstractfs.AbstractFileSystem.write","title":"<code>write(relative_path, data)</code>  <code>abstractmethod</code>","text":"<p>Write data to the file.</p> Source code in <code>backends/filesystem/abstractfs.py</code> <pre><code>@abstractmethod\ndef write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to the file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backendsfilesystemazureblobfs","title":"backends.filesystem.azureblobfs","text":""},{"location":"api/backends/#backends.filesystem.azureblobfs","title":"<code>backends.filesystem.azureblobfs</code>","text":""},{"location":"api/backends/#backends.filesystem.azureblobfs.AzureBlobFileSystem","title":"<code>AzureBlobFileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>Azure Blob Storage implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/azureblobfs.py</code> <pre><code>class AzureBlobFileSystem(AbstractFileSystem):\n    \"\"\"Azure Blob Storage implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, connection_string: str, container_name: str):\n        self.connection_string = connection_string\n        self.container_name = container_name\n        self.client = BlobServiceClient.from_connection_string(connection_string)\n        self.container = self.client.get_container_client(container_name)\n\n    def read(self, relative_path: str) -&gt; bytes:\n        \"\"\"Read data from an Azure Blob.\"\"\"\n        blob_client = self.container.get_blob_client(relative_path)\n        if not blob_client.exists():\n            raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the Azure container.\")\n        return blob_client.download_blob().readall()\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to an Azure Blob.\"\"\"\n        blob_client = self.container.get_blob_client(relative_path)\n        blob_client.upload_blob(data, overwrite=True)\n\n    def list(self, relative_dir: str) -&gt; list[str]:\n        \"\"\"List files in the specified Azure Blob directory.\"\"\"\n        blobs = self.container.list_blobs(name_starts_with=relative_dir)\n        return [blob.name for blob in blobs]\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete a file from Azure Blob Storage.\"\"\"\n        blob_client = self.container.get_blob_client(relative_path)\n        if not blob_client.exists():\n            raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the Azure container.\")\n        blob_client.delete_blob()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.azureblobfs.AzureBlobFileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete a file from Azure Blob Storage.</p> Source code in <code>backends/filesystem/azureblobfs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete a file from Azure Blob Storage.\"\"\"\n    blob_client = self.container.get_blob_client(relative_path)\n    if not blob_client.exists():\n        raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the Azure container.\")\n    blob_client.delete_blob()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.azureblobfs.AzureBlobFileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified Azure Blob directory.</p> Source code in <code>backends/filesystem/azureblobfs.py</code> <pre><code>def list(self, relative_dir: str) -&gt; list[str]:\n    \"\"\"List files in the specified Azure Blob directory.\"\"\"\n    blobs = self.container.list_blobs(name_starts_with=relative_dir)\n    return [blob.name for blob in blobs]\n</code></pre>"},{"location":"api/backends/#backends.filesystem.azureblobfs.AzureBlobFileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from an Azure Blob.</p> Source code in <code>backends/filesystem/azureblobfs.py</code> <pre><code>def read(self, relative_path: str) -&gt; bytes:\n    \"\"\"Read data from an Azure Blob.\"\"\"\n    blob_client = self.container.get_blob_client(relative_path)\n    if not blob_client.exists():\n        raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the Azure container.\")\n    return blob_client.download_blob().readall()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.azureblobfs.AzureBlobFileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to an Azure Blob.</p> Source code in <code>backends/filesystem/azureblobfs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to an Azure Blob.\"\"\"\n    blob_client = self.container.get_blob_client(relative_path)\n    blob_client.upload_blob(data, overwrite=True)\n</code></pre>"},{"location":"api/backends/#backendsfilesystemftpfs","title":"backends.filesystem.ftpfs","text":""},{"location":"api/backends/#backends.filesystem.ftpfs","title":"<code>backends.filesystem.ftpfs</code>","text":""},{"location":"api/backends/#backends.filesystem.ftpfs.FTPFileSystem","title":"<code>FTPFileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>FTP implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>class FTPFileSystem(AbstractFileSystem):\n    \"\"\"FTP implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, host: str, username: str, password: str, port: int = 21):\n        self.ftp = FTP()\n        self.ftp.connect(host, port)\n        self.ftp.login(username, password)\n\n    def read(self, relative_path: str) -&gt; bytes:\n        \"\"\"Read data from an FTP file.\"\"\"\n        with open('tempfile', 'wb') as temp_file:\n            self.ftp.retrbinary(f\"RETR {relative_path}\", temp_file.write)\n        with open('tempfile', 'rb') as temp_file:\n            return temp_file.read()\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to an FTP file.\"\"\"\n        with open('tempfile', 'wb') as temp_file:\n            temp_file.write(data)\n        with open('tempfile', 'rb') as temp_file:\n            self.ftp.storbinary(f\"STOR {relative_path}\", temp_file)\n\n    def list(self, relative_dir: str) -&gt; list[str]:\n        \"\"\"List files in the specified FTP directory.\"\"\"\n        return self.ftp.nlst(relative_dir)\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete a file from FTP.\"\"\"\n        self.ftp.delete(relative_path)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.FTPFileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete a file from FTP.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete a file from FTP.\"\"\"\n    self.ftp.delete(relative_path)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.FTPFileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified FTP directory.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def list(self, relative_dir: str) -&gt; list[str]:\n    \"\"\"List files in the specified FTP directory.\"\"\"\n    return self.ftp.nlst(relative_dir)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.FTPFileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from an FTP file.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def read(self, relative_path: str) -&gt; bytes:\n    \"\"\"Read data from an FTP file.\"\"\"\n    with open('tempfile', 'wb') as temp_file:\n        self.ftp.retrbinary(f\"RETR {relative_path}\", temp_file.write)\n    with open('tempfile', 'rb') as temp_file:\n        return temp_file.read()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.FTPFileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to an FTP file.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to an FTP file.\"\"\"\n    with open('tempfile', 'wb') as temp_file:\n        temp_file.write(data)\n    with open('tempfile', 'rb') as temp_file:\n        self.ftp.storbinary(f\"STOR {relative_path}\", temp_file)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.SFTPFileSystem","title":"<code>SFTPFileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>SFTP implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>class SFTPFileSystem(AbstractFileSystem):\n    \"\"\"SFTP implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, host: str, username: str, password: str, port: int = 22):\n        self.cnopts = pysftp.CnOpts()\n        self.cnopts.hostkeys = None  # Disable host key verification (optional, for testing only)\n        self.connection = pysftp.Connection(\n            host=host, username=username, password=password, port=port, cnopts=self.cnopts\n        )\n\n    def read(self, relative_path: str) -&gt; bytes:\n        \"\"\"Read data from an SFTP file.\"\"\"\n        with self.connection.open(relative_path, 'rb') as file:\n            return file.read()\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to an SFTP file.\"\"\"\n        with self.connection.open(relative_path, 'wb') as file:\n            file.write(data)\n\n    def list(self, relative_dir: str) -&gt; list[str]:\n        \"\"\"List files in the specified SFTP directory.\"\"\"\n        return self.connection.listdir(relative_dir)\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete a file from SFTP.\"\"\"\n        self.connection.remove(relative_path)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.SFTPFileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete a file from SFTP.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete a file from SFTP.\"\"\"\n    self.connection.remove(relative_path)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.SFTPFileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified SFTP directory.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def list(self, relative_dir: str) -&gt; list[str]:\n    \"\"\"List files in the specified SFTP directory.\"\"\"\n    return self.connection.listdir(relative_dir)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.SFTPFileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from an SFTP file.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def read(self, relative_path: str) -&gt; bytes:\n    \"\"\"Read data from an SFTP file.\"\"\"\n    with self.connection.open(relative_path, 'rb') as file:\n        return file.read()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.ftpfs.SFTPFileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to an SFTP file.</p> Source code in <code>backends/filesystem/ftpfs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to an SFTP file.\"\"\"\n    with self.connection.open(relative_path, 'wb') as file:\n        file.write(data)\n</code></pre>"},{"location":"api/backends/#backendsfilesystemgcsfs","title":"backends.filesystem.gcsfs","text":""},{"location":"api/backends/#backends.filesystem.gcsfs","title":"<code>backends.filesystem.gcsfs</code>","text":""},{"location":"api/backends/#backends.filesystem.gcsfs.GCSFileSystem","title":"<code>GCSFileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>Google Cloud Storage implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/gcsfs.py</code> <pre><code>class GCSFileSystem(AbstractFileSystem):\n    \"\"\"Google Cloud Storage implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, bucket_name: str):\n        self.bucket_name = bucket_name\n        self.client = storage.Client()\n        self.bucket = self.client.bucket(bucket_name)\n\n    def read(self, relative_path: str) -&gt; bytes:\n        \"\"\"Read data from a GCS file.\"\"\"\n        blob = self.bucket.blob(relative_path)\n        if not blob.exists():\n            raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the GCS bucket.\")\n        return blob.download_as_bytes()\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to a GCS file.\"\"\"\n        blob = self.bucket.blob(relative_path)\n        blob.upload_from_string(data)\n\n    def list(self, relative_dir: str) -&gt; list[str]:\n        \"\"\"List files in the specified GCS directory.\"\"\"\n        blobs = self.client.list_blobs(self.bucket_name, prefix=relative_dir)\n        return [blob.name for blob in blobs]\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete a file from GCS.\"\"\"\n        blob = self.bucket.blob(relative_path)\n        if not blob.exists():\n            raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the GCS bucket.\")\n        blob.delete()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.gcsfs.GCSFileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete a file from GCS.</p> Source code in <code>backends/filesystem/gcsfs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete a file from GCS.\"\"\"\n    blob = self.bucket.blob(relative_path)\n    if not blob.exists():\n        raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the GCS bucket.\")\n    blob.delete()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.gcsfs.GCSFileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified GCS directory.</p> Source code in <code>backends/filesystem/gcsfs.py</code> <pre><code>def list(self, relative_dir: str) -&gt; list[str]:\n    \"\"\"List files in the specified GCS directory.\"\"\"\n    blobs = self.client.list_blobs(self.bucket_name, prefix=relative_dir)\n    return [blob.name for blob in blobs]\n</code></pre>"},{"location":"api/backends/#backends.filesystem.gcsfs.GCSFileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from a GCS file.</p> Source code in <code>backends/filesystem/gcsfs.py</code> <pre><code>def read(self, relative_path: str) -&gt; bytes:\n    \"\"\"Read data from a GCS file.\"\"\"\n    blob = self.bucket.blob(relative_path)\n    if not blob.exists():\n        raise FileNotFoundError(f\"The file '{relative_path}' does not exist in the GCS bucket.\")\n    return blob.download_as_bytes()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.gcsfs.GCSFileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to a GCS file.</p> Source code in <code>backends/filesystem/gcsfs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to a GCS file.\"\"\"\n    blob = self.bucket.blob(relative_path)\n    blob.upload_from_string(data)\n</code></pre>"},{"location":"api/backends/#backendsfilesystemlocalfs","title":"backends.filesystem.localfs","text":""},{"location":"api/backends/#backends.filesystem.localfs","title":"<code>backends.filesystem.localfs</code>","text":""},{"location":"api/backends/#backends.filesystem.localfs.LocalFileSystem","title":"<code>LocalFileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>Local file system implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/localfs.py</code> <pre><code>class LocalFileSystem(AbstractFileSystem):\n    \"\"\"Local file system implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, root: str = '.'):\n        self.root = Path(root)\n        if not self.root.exists():\n            self.root.mkdir(parents=True)\n\n    def read(self, relative_path: str):\n        \"\"\"Read data from the local file.\"\"\"\n        path = self.root / relative_path\n        if not path.exists():\n            raise FileNotFoundError(f\"The file '{relative_path}' does not exist.\")\n        if not path.is_file():\n            raise TypeError(f\"The file '{relative_path}' is not a file.\")\n\n        with open(self.root / relative_path, 'rb') as file:\n            return file.read()\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to the local file.\"\"\"\n        with open(self.root / relative_path, 'wb') as file:\n            file.write(data)\n\n    def list(self, relative_dir: str):\n        \"\"\"List files in the specified directory.\"\"\"\n        return os.listdir(self.root / relative_dir)\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete the file.\"\"\"\n        (self.root / relative_path).unlink(missing_ok=True)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.localfs.LocalFileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete the file.</p> Source code in <code>backends/filesystem/localfs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete the file.\"\"\"\n    (self.root / relative_path).unlink(missing_ok=True)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.localfs.LocalFileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified directory.</p> Source code in <code>backends/filesystem/localfs.py</code> <pre><code>def list(self, relative_dir: str):\n    \"\"\"List files in the specified directory.\"\"\"\n    return os.listdir(self.root / relative_dir)\n</code></pre>"},{"location":"api/backends/#backends.filesystem.localfs.LocalFileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from the local file.</p> Source code in <code>backends/filesystem/localfs.py</code> <pre><code>def read(self, relative_path: str):\n    \"\"\"Read data from the local file.\"\"\"\n    path = self.root / relative_path\n    if not path.exists():\n        raise FileNotFoundError(f\"The file '{relative_path}' does not exist.\")\n    if not path.is_file():\n        raise TypeError(f\"The file '{relative_path}' is not a file.\")\n\n    with open(self.root / relative_path, 'rb') as file:\n        return file.read()\n</code></pre>"},{"location":"api/backends/#backends.filesystem.localfs.LocalFileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to the local file.</p> Source code in <code>backends/filesystem/localfs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to the local file.\"\"\"\n    with open(self.root / relative_path, 'wb') as file:\n        file.write(data)\n</code></pre>"},{"location":"api/backends/#backendsfilesystems3fs","title":"backends.filesystem.s3fs","text":""},{"location":"api/backends/#backends.filesystem.s3fs","title":"<code>backends.filesystem.s3fs</code>","text":""},{"location":"api/backends/#backends.filesystem.s3fs.S3FileSystem","title":"<code>S3FileSystem</code>","text":"<p>               Bases: <code>AbstractFileSystem</code></p> <p>S3 file system implementation of the FileSystemInterface.</p> Source code in <code>backends/filesystem/s3fs.py</code> <pre><code>class S3FileSystem(AbstractFileSystem):\n    \"\"\"S3 file system implementation of the FileSystemInterface.\"\"\"\n\n    def __init__(self, bucket_name: str, region: str = \"us-east-1\"):\n        self.bucket_name = bucket_name\n        self.region = region\n        self.s3 = boto3.client(\"s3\", region_name=region)\n\n    def read(self, relative_path: str) -&gt; bytes:\n        \"\"\"Read data from the S3 file.\"\"\"\n        try:\n            response = self.s3.get_object(Bucket=self.bucket_name, Key=relative_path)\n            return response[\"Body\"].read()\n        except self.s3.exceptions.NoSuchKey:\n            raise FileNotFoundError(\n                f\"The file '{relative_path}' does not exist in the S3 bucket.\"\n            )\n        except (NoCredentialsError, PartialCredentialsError):\n            raise PERMISSION_ERROR\n\n    def write(self, relative_path: str, data: bytes):\n        \"\"\"Write data to an S3 file.\"\"\"\n        try:\n            self.s3.put_object(Bucket=self.bucket_name, Key=relative_path, Body=data)\n        except (NoCredentialsError, PartialCredentialsError):\n            raise PERMISSION_ERROR\n\n    def list(self, relative_dir: str) -&gt; list[str]:\n        \"\"\"List files in the specified S3 bucket.\"\"\"\n        try:\n            response = self.s3.list_objects_v2(\n                Bucket=self.bucket_name, Prefix=relative_dir\n            )\n            if \"Contents\" in response:\n                return [item[\"Key\"] for item in response[\"Contents\"]]\n            return []\n        except (NoCredentialsError, PartialCredentialsError):\n            raise PERMISSION_ERROR\n\n    def delete(self, relative_path: str):\n        \"\"\"Delete the file.\"\"\"\n        try:\n            self.s3.delete_object(Bucket=self.bucket_name, Key=relative_path)\n        except self.s3.exceptions.NoSuchKey:\n            raise FileNotFoundError(\n                f\"The file '{relative_path}' does not exist in the S3 bucket.\"\n            )\n        except (NoCredentialsError, PartialCredentialsError):\n            raise PERMISSION_ERROR\n</code></pre>"},{"location":"api/backends/#backends.filesystem.s3fs.S3FileSystem.delete","title":"<code>delete(relative_path)</code>","text":"<p>Delete the file.</p> Source code in <code>backends/filesystem/s3fs.py</code> <pre><code>def delete(self, relative_path: str):\n    \"\"\"Delete the file.\"\"\"\n    try:\n        self.s3.delete_object(Bucket=self.bucket_name, Key=relative_path)\n    except self.s3.exceptions.NoSuchKey:\n        raise FileNotFoundError(\n            f\"The file '{relative_path}' does not exist in the S3 bucket.\"\n        )\n    except (NoCredentialsError, PartialCredentialsError):\n        raise PERMISSION_ERROR\n</code></pre>"},{"location":"api/backends/#backends.filesystem.s3fs.S3FileSystem.list","title":"<code>list(relative_dir)</code>","text":"<p>List files in the specified S3 bucket.</p> Source code in <code>backends/filesystem/s3fs.py</code> <pre><code>def list(self, relative_dir: str) -&gt; list[str]:\n    \"\"\"List files in the specified S3 bucket.\"\"\"\n    try:\n        response = self.s3.list_objects_v2(\n            Bucket=self.bucket_name, Prefix=relative_dir\n        )\n        if \"Contents\" in response:\n            return [item[\"Key\"] for item in response[\"Contents\"]]\n        return []\n    except (NoCredentialsError, PartialCredentialsError):\n        raise PERMISSION_ERROR\n</code></pre>"},{"location":"api/backends/#backends.filesystem.s3fs.S3FileSystem.read","title":"<code>read(relative_path)</code>","text":"<p>Read data from the S3 file.</p> Source code in <code>backends/filesystem/s3fs.py</code> <pre><code>def read(self, relative_path: str) -&gt; bytes:\n    \"\"\"Read data from the S3 file.\"\"\"\n    try:\n        response = self.s3.get_object(Bucket=self.bucket_name, Key=relative_path)\n        return response[\"Body\"].read()\n    except self.s3.exceptions.NoSuchKey:\n        raise FileNotFoundError(\n            f\"The file '{relative_path}' does not exist in the S3 bucket.\"\n        )\n    except (NoCredentialsError, PartialCredentialsError):\n        raise PERMISSION_ERROR\n</code></pre>"},{"location":"api/backends/#backends.filesystem.s3fs.S3FileSystem.write","title":"<code>write(relative_path, data)</code>","text":"<p>Write data to an S3 file.</p> Source code in <code>backends/filesystem/s3fs.py</code> <pre><code>def write(self, relative_path: str, data: bytes):\n    \"\"\"Write data to an S3 file.\"\"\"\n    try:\n        self.s3.put_object(Bucket=self.bucket_name, Key=relative_path, Body=data)\n    except (NoCredentialsError, PartialCredentialsError):\n        raise PERMISSION_ERROR\n</code></pre>"},{"location":"api/backends/#backendskmsabstractkms","title":"backends.kms.abstractkms","text":""},{"location":"api/backends/#backends.kms.abstractkms","title":"<code>backends.kms.abstractkms</code>","text":""},{"location":"api/backends/#backends.kms.abstractkms.AbstractKMS","title":"<code>AbstractKMS</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Key Management System operations.</p> Source code in <code>backends/kms/abstractkms.py</code> <pre><code>class AbstractKMS(ABC):\n    \"\"\"\n    Abstract base class for Key Management System operations.\n    \"\"\"\n\n    @abstractmethod\n    def generate_kek(self, description: str) -&gt; str:\n        \"\"\"\n        Generate a Key Encryption Key (KEK).\n\n        Args:\n            description (str): Description for the key.\n        Returns:\n            str: Key ID of the generated KEK.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def encrypt_dek(self, dek: bytes, key_id: str) -&gt; bytes:\n        \"\"\"\n        Encrypt a Data Encryption Key (DEK).\n\n        Args:\n            dek (bytes): The plaintext DEK to encrypt.\n            key_id (str): The Key ID to use for encryption.\n        Returns:\n            bytes: Encrypted DEK as bytes.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def decrypt_dek(self, encrypted_dek: bytes) -&gt; bytes:\n        \"\"\"\n        Decrypt a Data Encryption Key (DEK).\n\n        Args:\n            encrypted_dek (bytes): The encrypted DEK to decrypt.\n        Returns:\n            bytes: Plaintext DEK as bytes.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/backends/#backends.kms.abstractkms.AbstractKMS.decrypt_dek","title":"<code>decrypt_dek(encrypted_dek)</code>  <code>abstractmethod</code>","text":"<p>Decrypt a Data Encryption Key (DEK).</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_dek</code> <code>bytes</code> <p>The encrypted DEK to decrypt.</p> required <p>Returns:     bytes: Plaintext DEK as bytes.</p> Source code in <code>backends/kms/abstractkms.py</code> <pre><code>@abstractmethod\ndef decrypt_dek(self, encrypted_dek: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt a Data Encryption Key (DEK).\n\n    Args:\n        encrypted_dek (bytes): The encrypted DEK to decrypt.\n    Returns:\n        bytes: Plaintext DEK as bytes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.kms.abstractkms.AbstractKMS.encrypt_dek","title":"<code>encrypt_dek(dek, key_id)</code>  <code>abstractmethod</code>","text":"<p>Encrypt a Data Encryption Key (DEK).</p> <p>Parameters:</p> Name Type Description Default <code>dek</code> <code>bytes</code> <p>The plaintext DEK to encrypt.</p> required <code>key_id</code> <code>str</code> <p>The Key ID to use for encryption.</p> required <p>Returns:     bytes: Encrypted DEK as bytes.</p> Source code in <code>backends/kms/abstractkms.py</code> <pre><code>@abstractmethod\ndef encrypt_dek(self, dek: bytes, key_id: str) -&gt; bytes:\n    \"\"\"\n    Encrypt a Data Encryption Key (DEK).\n\n    Args:\n        dek (bytes): The plaintext DEK to encrypt.\n        key_id (str): The Key ID to use for encryption.\n    Returns:\n        bytes: Encrypted DEK as bytes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backends.kms.abstractkms.AbstractKMS.generate_kek","title":"<code>generate_kek(description)</code>  <code>abstractmethod</code>","text":"<p>Generate a Key Encryption Key (KEK).</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Description for the key.</p> required <p>Returns:     str: Key ID of the generated KEK.</p> Source code in <code>backends/kms/abstractkms.py</code> <pre><code>@abstractmethod\ndef generate_kek(self, description: str) -&gt; str:\n    \"\"\"\n    Generate a Key Encryption Key (KEK).\n\n    Args:\n        description (str): Description for the key.\n    Returns:\n        str: Key ID of the generated KEK.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/backends/#backendskmsawskms","title":"backends.kms.awskms","text":""},{"location":"api/backends/#backends.kms.awskms","title":"<code>backends.kms.awskms</code>","text":""},{"location":"api/backends/#backends.kms.awskms.AWSKMS","title":"<code>AWSKMS</code>","text":"<p>               Bases: <code>AbstractKMS</code></p> <p>AWS KMS implementation of the AbstractKMS.</p> Source code in <code>backends/kms/awskms.py</code> <pre><code>class AWSKMS(AbstractKMS):\n    \"\"\"\n    AWS KMS implementation of the AbstractKMS.\n    \"\"\"\n\n    def __init__(self):\n        self.kms_client = boto3.client('kms')\n\n    def generate_kek(self, description: str) -&gt; str:\n        response = self.kms_client.create_key(\n            Description=description,\n            KeyUsage='ENCRYPT_DECRYPT',\n            CustomerMasterKeySpec='SYMMETRIC_DEFAULT'\n        )\n        return response['KeyMetadata']['KeyId']\n\n    def encrypt_dek(self, dek: bytes, key_id: str) -&gt; bytes:\n        response = self.kms_client.encrypt(\n            KeyId=key_id,\n            Plaintext=dek\n        )\n        return response['CiphertextBlob']\n\n    def decrypt_dek(self, encrypted_dek: bytes) -&gt; bytes:\n        response = self.kms_client.decrypt(\n            CiphertextBlob=encrypted_dek\n        )\n        return response['Plaintext']\n</code></pre>"},{"location":"api/backends/#backendskmslocalkms","title":"backends.kms.localkms","text":""},{"location":"api/backends/#backends.kms.localkms","title":"<code>backends.kms.localkms</code>","text":""},{"location":"api/backends/#backends.kms.localkms.LocalKMS","title":"<code>LocalKMS</code>","text":"<p>               Bases: <code>AbstractKMS</code></p> <p>Local implementation of the AbstractKMS for testing purposes with persistent storage.</p> Source code in <code>backends/kms/localkms.py</code> <pre><code>class LocalKMS(AbstractKMS):\n    \"\"\"\n    Local implementation of the AbstractKMS for testing purposes with persistent storage.\n    \"\"\"\n    def __init__(self, storage_file: str = \"local_kms_storage.json\"):\n        self.storage_file = Path(storage_file)\n\n        if not self.storage_file.exists():\n            self.storage_file.parent.mkdir(parents=True, exist_ok=True)\n            self.storage_file.write_text('{}', encoding='utf-8')\n\n        self.keys = self._load_keys()\n        self.counter = len(self.keys)\n\n    def _load_keys(self) -&gt; dict:\n        if self.storage_file.exists():\n            return json.loads(self.storage_file.read_text(encoding='utf-8'))\n        return {}\n\n    def _save_keys(self):\n        self.storage_file.write_text(json.dumps(self.keys), encoding='utf-8')\n\n    def generate_kek(self, description: str) -&gt; str:\n        key_id = f\"local-key-{self.counter:02d}\"\n        self.keys[key_id] = {\n            \"description\": description,\n            \"key_material\": f\"key-material-{self.counter}\".encode().hex()\n        }\n        self.counter += 1\n        self._save_keys()\n        return key_id\n\n    def encrypt_dek(self, dek: bytes, key_id: str) -&gt; bytes:\n        if key_id not in self.keys:\n            raise ValueError(\"Invalid Key ID\")\n        return dek[::-1]  # Example encryption: reverse the bytes\n\n    def decrypt_dek(self, encrypted_dek: bytes) -&gt; bytes:\n        return encrypted_dek[::-1]  # Reverse again to decrypt\n</code></pre>"},{"location":"api/helpers/","title":"Helpers","text":""},{"location":"api/helpers/#helpersaes","title":"helpers.aes","text":""},{"location":"api/helpers/#helpers.aes","title":"<code>helpers.aes</code>","text":"<p>This module provides a class for encrypting and decrypting data using AES in GCM mode.</p>"},{"location":"api/helpers/#helpers.aes.AESHelper","title":"<code>AESHelper</code>","text":"Source code in <code>helpers/aes.py</code> <pre><code>class AESHelper:\n    def __init__(self, key: bytes | str):\n        \"\"\"\n        Initialize the AESHelper instance with the provided key.\n\n        Args:\n            key (bytes | str): The key to use for encryption and decryption.\n\n        Returns:\n            The hex-encoded AES key.\n\n        Raises:\n            TypeError: If the key is not a string or bytes.\n            ValueError: If the key is not a string or bytes and cannot be converted to bytes.\n        \"\"\"\n        if not isinstance(key, (bytes, str)):\n            raise TypeError(\"Key must be a string or bytes.\")\n\n        if isinstance(key, str):\n            key = self.try_encode_str(key)\n\n        if not isinstance(key, bytes):\n            raise ValueError(\"Cannot convert key to bytes.\")\n\n        if len(key) not in [16, 24, 32]:\n            # This is a hacky way to resize the key to an UUID and then get the hex of it\n            key = hash_bytes(key).hex.encode()\n\n        self.key = key\n\n    @staticmethod\n    def try_encode_str(key: str) -&gt; bytes | None:\n        \"\"\"\n        Try to convert a string key to bytes.\n\n        Args:\n            key (str): The string key to convert.\n\n        Returns:\n            bytes | None: The converted key or None if conversion fails.\n        \"\"\"\n        if not isinstance(key, str):\n            return key\n        try:\n            return bytes.fromhex(key)\n        except Exception:\n            pass\n        try:\n            return key.encode()\n        except Exception:\n            pass\n\n    @staticmethod\n    def get_random_key(size: Literal[16, 24, 32] = 16) -&gt; bytes:\n        \"\"\"\n        Generate a random AES key of the specified size (16, 24, or 32 bytes).\n\n        Args:\n            size (Literal[16, 24, 32]): The size of the key to generate.\n\n        Returns:\n            bytes: The generated key as a hex-encoded string.\n        \"\"\"\n        return get_random_bytes(size)\n\n    @staticmethod\n    def _verify_data_type(data: bytes):\n        \"\"\"\n        Verify that the provided data is of type bytes.\n\n        Args:\n            data (bytes): The data to verify.\n\n        Raises:\n            TypeError: If the data is not bytes.\n        \"\"\"\n        if not isinstance(data, bytes):\n            raise TypeError(\"Data must be bytes.\")\n\n    def encrypt(self, data: bytes) -&gt; bytes:\n        \"\"\"\n        Encrypt data using AES in GCM mode.\n\n        Args:\n            data (bytes): The data to encrypt.\n\n        Returns:\n            bytes: The ciphertext, which includes the nonce and authentication tag.\n        \"\"\"\n        self._verify_data_type(data)\n        cipher = AES.new(self.key, AES.MODE_GCM)  # GCM mode automatically generates a nonce\n        ciphertext, tag = cipher.encrypt_and_digest(data)\n        return cipher.nonce + tag + ciphertext\n\n    def decrypt(self, encrypted_data: bytes) -&gt; bytes:\n        \"\"\"\n        Decrypt data using AES in GCM mode.\n        Extracts the nonce, tag, and ciphertext from the encrypted data.\n\n        Args:\n            encrypted_data (bytes): The encrypted data to decrypt.\n\n        Returns:\n            bytes: The decrypted data.\n        \"\"\"\n        self._verify_data_type(encrypted_data)\n        nonce = encrypted_data[:16]  # GCM nonce is 16 bytes\n        tag = encrypted_data[16:32]  # GCM tag is 16 bytes\n        ciphertext = encrypted_data[32:]\n        cipher = AES.new(self.key, AES.MODE_GCM, nonce=nonce)\n        return cipher.decrypt_and_verify(ciphertext, tag)\n</code></pre>"},{"location":"api/helpers/#helpers.aes.AESHelper.__init__","title":"<code>__init__(key)</code>","text":"<p>Initialize the AESHelper instance with the provided key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to use for encryption and decryption.</p> required <p>Returns:</p> Type Description <p>The hex-encoded AES key.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the key is not a string or bytes.</p> <code>ValueError</code> <p>If the key is not a string or bytes and cannot be converted to bytes.</p> Source code in <code>helpers/aes.py</code> <pre><code>def __init__(self, key: bytes | str):\n    \"\"\"\n    Initialize the AESHelper instance with the provided key.\n\n    Args:\n        key (bytes | str): The key to use for encryption and decryption.\n\n    Returns:\n        The hex-encoded AES key.\n\n    Raises:\n        TypeError: If the key is not a string or bytes.\n        ValueError: If the key is not a string or bytes and cannot be converted to bytes.\n    \"\"\"\n    if not isinstance(key, (bytes, str)):\n        raise TypeError(\"Key must be a string or bytes.\")\n\n    if isinstance(key, str):\n        key = self.try_encode_str(key)\n\n    if not isinstance(key, bytes):\n        raise ValueError(\"Cannot convert key to bytes.\")\n\n    if len(key) not in [16, 24, 32]:\n        # This is a hacky way to resize the key to an UUID and then get the hex of it\n        key = hash_bytes(key).hex.encode()\n\n    self.key = key\n</code></pre>"},{"location":"api/helpers/#helpers.aes.AESHelper.decrypt","title":"<code>decrypt(encrypted_data)</code>","text":"<p>Decrypt data using AES in GCM mode. Extracts the nonce, tag, and ciphertext from the encrypted data.</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_data</code> <code>bytes</code> <p>The encrypted data to decrypt.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The decrypted data.</p> Source code in <code>helpers/aes.py</code> <pre><code>def decrypt(self, encrypted_data: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt data using AES in GCM mode.\n    Extracts the nonce, tag, and ciphertext from the encrypted data.\n\n    Args:\n        encrypted_data (bytes): The encrypted data to decrypt.\n\n    Returns:\n        bytes: The decrypted data.\n    \"\"\"\n    self._verify_data_type(encrypted_data)\n    nonce = encrypted_data[:16]  # GCM nonce is 16 bytes\n    tag = encrypted_data[16:32]  # GCM tag is 16 bytes\n    ciphertext = encrypted_data[32:]\n    cipher = AES.new(self.key, AES.MODE_GCM, nonce=nonce)\n    return cipher.decrypt_and_verify(ciphertext, tag)\n</code></pre>"},{"location":"api/helpers/#helpers.aes.AESHelper.encrypt","title":"<code>encrypt(data)</code>","text":"<p>Encrypt data using AES in GCM mode.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to encrypt.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The ciphertext, which includes the nonce and authentication tag.</p> Source code in <code>helpers/aes.py</code> <pre><code>def encrypt(self, data: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt data using AES in GCM mode.\n\n    Args:\n        data (bytes): The data to encrypt.\n\n    Returns:\n        bytes: The ciphertext, which includes the nonce and authentication tag.\n    \"\"\"\n    self._verify_data_type(data)\n    cipher = AES.new(self.key, AES.MODE_GCM)  # GCM mode automatically generates a nonce\n    ciphertext, tag = cipher.encrypt_and_digest(data)\n    return cipher.nonce + tag + ciphertext\n</code></pre>"},{"location":"api/helpers/#helpers.aes.AESHelper.get_random_key","title":"<code>get_random_key(size=16)</code>  <code>staticmethod</code>","text":"<p>Generate a random AES key of the specified size (16, 24, or 32 bytes).</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Literal[16, 24, 32]</code> <p>The size of the key to generate.</p> <code>16</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The generated key as a hex-encoded string.</p> Source code in <code>helpers/aes.py</code> <pre><code>@staticmethod\ndef get_random_key(size: Literal[16, 24, 32] = 16) -&gt; bytes:\n    \"\"\"\n    Generate a random AES key of the specified size (16, 24, or 32 bytes).\n\n    Args:\n        size (Literal[16, 24, 32]): The size of the key to generate.\n\n    Returns:\n        bytes: The generated key as a hex-encoded string.\n    \"\"\"\n    return get_random_bytes(size)\n</code></pre>"},{"location":"api/helpers/#helpers.aes.AESHelper.try_encode_str","title":"<code>try_encode_str(key)</code>  <code>staticmethod</code>","text":"<p>Try to convert a string key to bytes.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The string key to convert.</p> required <p>Returns:</p> Type Description <code>bytes | None</code> <p>bytes | None: The converted key or None if conversion fails.</p> Source code in <code>helpers/aes.py</code> <pre><code>@staticmethod\ndef try_encode_str(key: str) -&gt; bytes | None:\n    \"\"\"\n    Try to convert a string key to bytes.\n\n    Args:\n        key (str): The string key to convert.\n\n    Returns:\n        bytes | None: The converted key or None if conversion fails.\n    \"\"\"\n    if not isinstance(key, str):\n        return key\n    try:\n        return bytes.fromhex(key)\n    except Exception:\n        pass\n    try:\n        return key.encode()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/helpers/#helpersecdh","title":"helpers.ecdh","text":""},{"location":"api/helpers/#helpers.ecdh","title":"<code>helpers.ecdh</code>","text":"<p>This module provides a class for Elliptic-curve Diffie-Hellman (ECDH) key exchange operations, including key pair generation, serialization/deserialization of keys, shared secret generation, and data encryption/decryption.</p>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper","title":"<code>ECDHHelper</code>","text":"<p>Helper class for ECDH key exchange operations, including key pair generation, serialization/deserialization of keys, shared secret generation, and data encryption/decryption.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>class ECDHHelper:\n    \"\"\"\n    Helper class for ECDH key exchange operations, including key pair generation,\n    serialization/deserialization of keys, shared secret generation, and data encryption/decryption.\n    \"\"\"\n\n    @staticmethod\n    @overload\n    def generate_key_pair(\n        out_format: Literal[KeyFormat.OBJECT, 0],\n    ) -&gt; KeyPairObjects: ...\n\n    @staticmethod\n    @overload\n    def generate_key_pair(out_format: Literal[KeyFormat.BYTE, 1]) -&gt; KeyPairBytes: ...\n\n    @staticmethod\n    @overload\n    def generate_key_pair(\n        out_format: Literal[KeyFormat.STRING, 2],\n    ) -&gt; KeyPairStrings: ...\n\n    @staticmethod\n    def generate_key_pair(out_format: KeyFormat | int = KeyFormat.OBJECT) -&gt; TKeyPair:\n        \"\"\"\n        Generates an elliptic curve key pair in the specified format.\n\n        Args:\n            out_format (KeyFormat | int): Desired output format for the key pair (OBJECT, BYTE, STRING).\n\n        Returns:\n            TKeyPair: Key pair in the specified format.\n        \"\"\"\n        if out_format not in [KeyFormat.BYTE, KeyFormat.STRING, KeyFormat.OBJECT]:\n            out_format = KeyFormat.OBJECT\n\n        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())\n        public_key = private_key.public_key()\n\n        if out_format == KeyFormat.BYTE:\n            return KeyPairBytes(\n                ECDHHelper.serialize_private_key(private_key, return_type=bytes),\n                ECDHHelper.serialize_public_key(public_key, return_type=bytes),\n            )\n        elif out_format == KeyFormat.STRING:\n            return KeyPairStrings(\n                ECDHHelper.serialize_private_key(private_key, return_type=str),\n                ECDHHelper.serialize_public_key(public_key, return_type=str),\n            )\n        elif out_format == KeyFormat.OBJECT:\n            return KeyPairObjects(private_key, public_key)\n\n    @staticmethod\n    def serialize_private_key(\n        private_key: ec.EllipticCurvePrivateKey,\n        return_type: type[StrBytes] = bytes,\n    ) -&gt; StrBytes:\n        \"\"\"\n        Serializes a private key to PEM format.\n\n        Args:\n            private_key (ec.EllipticCurvePrivateKey): Elliptic curve private key.\n            return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes.\n\n        Returns:\n            StrBytes: Serialized private key in PEM format.\n        \"\"\"\n        key = private_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return key.decode() if return_type is str else key\n\n    @staticmethod\n    def deserialize_private_key(data: bytes | str):\n        \"\"\"\n        Deserializes a PEM-encoded private key from bytes or hex string.\n\n        Args:\n            data (bytes | str): Serialized private key in bytes or hex string format.\n\n        Returns:\n            ec.EllipticCurvePrivateKey: Elliptic curve private key object.\n        \"\"\"\n        if isinstance(data, str):\n            data = bytes.fromhex(data)\n        return serialization.load_pem_private_key(\n            data, password=None, backend=default_backend()\n        )\n\n    @staticmethod\n    def serialize_public_key(\n        public_key: ec.EllipticCurvePublicKey,\n        return_type: type[StrBytes] = bytes,\n    ) -&gt; StrBytes:\n        \"\"\"\n        Serializes a public key to PEM format.\n\n        Args:\n            public_key (ec.EllipticCurvePublicKey): Elliptic curve public key.\n            return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes.\n\n        Returns:\n            StrBytes: Serialized public key in PEM format.\n        \"\"\"\n        key = public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        return key.decode() if return_type is str else key\n\n    @staticmethod\n    def deserialize_public_key(data: bytes | str):\n        \"\"\"\n        Deserializes a PEM-encoded public key from bytes or hex string.\n\n        Args:\n            data (bytes | str): Serialized public key in bytes or hex string format.\n\n        Returns:\n            ec.EllipticCurvePublicKey: Elliptic curve public key object.\n        \"\"\"\n        if isinstance(data, str):\n            data = bytes.fromhex(data)\n        return serialization.load_pem_public_key(data, backend=default_backend())\n\n    @staticmethod\n    def generate_shared_secret(\n        private_key: ec.EllipticCurvePrivateKey,\n        public_key: ec.EllipticCurvePublicKey,\n    ) -&gt; bytes:\n        \"\"\"\n        Generates a shared secret using ECDH key exchange.\n\n        Args:\n            private_key (ec.EllipticCurvePrivateKey): Elliptic curve private key.\n            public_key (ec.EllipticCurvePublicKey): Elliptic curve public key.\n\n        Returns:\n            bytes: Shared secret bytes.\n        \"\"\"\n        shared_secret = private_key.exchange(ec.ECDH(), public_key)\n        return shared_secret\n\n    @staticmethod\n    def encrypt_data(data: bytes, shared_secret: bytes) -&gt; bytes:\n        \"\"\"\n        Encrypts data using AES encryption with the given shared secret.\n\n        Args:\n            data (bytes): Data to encrypt.\n            shared_secret (bytes): Shared secret used for encryption.\n\n        Returns:\n            bytes: Encrypted data (ciphertext).\n        \"\"\"\n        ciphertext = AESHelper(shared_secret).encrypt(data)\n        return ciphertext\n\n    @staticmethod\n    def decrypt_data(ciphertext: bytes, shared_secret: bytes) -&gt; bytes:\n        \"\"\"\n        Decrypts data using AES encryption with the given shared secret.\n\n        Args:\n            ciphertext (bytes): Encrypted data (ciphertext).\n            shared_secret (bytes): Shared secret used for decryption.\n\n        Returns:\n            bytes: Decrypted data.\n        \"\"\"\n        data = AESHelper(shared_secret).decrypt(ciphertext)\n        return data\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.decrypt_data","title":"<code>decrypt_data(ciphertext, shared_secret)</code>  <code>staticmethod</code>","text":"<p>Decrypts data using AES encryption with the given shared secret.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes</code> <p>Encrypted data (ciphertext).</p> required <code>shared_secret</code> <code>bytes</code> <p>Shared secret used for decryption.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Decrypted data.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef decrypt_data(ciphertext: bytes, shared_secret: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypts data using AES encryption with the given shared secret.\n\n    Args:\n        ciphertext (bytes): Encrypted data (ciphertext).\n        shared_secret (bytes): Shared secret used for decryption.\n\n    Returns:\n        bytes: Decrypted data.\n    \"\"\"\n    data = AESHelper(shared_secret).decrypt(ciphertext)\n    return data\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.deserialize_private_key","title":"<code>deserialize_private_key(data)</code>  <code>staticmethod</code>","text":"<p>Deserializes a PEM-encoded private key from bytes or hex string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | str</code> <p>Serialized private key in bytes or hex string format.</p> required <p>Returns:</p> Type Description <p>ec.EllipticCurvePrivateKey: Elliptic curve private key object.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef deserialize_private_key(data: bytes | str):\n    \"\"\"\n    Deserializes a PEM-encoded private key from bytes or hex string.\n\n    Args:\n        data (bytes | str): Serialized private key in bytes or hex string format.\n\n    Returns:\n        ec.EllipticCurvePrivateKey: Elliptic curve private key object.\n    \"\"\"\n    if isinstance(data, str):\n        data = bytes.fromhex(data)\n    return serialization.load_pem_private_key(\n        data, password=None, backend=default_backend()\n    )\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.deserialize_public_key","title":"<code>deserialize_public_key(data)</code>  <code>staticmethod</code>","text":"<p>Deserializes a PEM-encoded public key from bytes or hex string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | str</code> <p>Serialized public key in bytes or hex string format.</p> required <p>Returns:</p> Type Description <p>ec.EllipticCurvePublicKey: Elliptic curve public key object.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef deserialize_public_key(data: bytes | str):\n    \"\"\"\n    Deserializes a PEM-encoded public key from bytes or hex string.\n\n    Args:\n        data (bytes | str): Serialized public key in bytes or hex string format.\n\n    Returns:\n        ec.EllipticCurvePublicKey: Elliptic curve public key object.\n    \"\"\"\n    if isinstance(data, str):\n        data = bytes.fromhex(data)\n    return serialization.load_pem_public_key(data, backend=default_backend())\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.encrypt_data","title":"<code>encrypt_data(data, shared_secret)</code>  <code>staticmethod</code>","text":"<p>Encrypts data using AES encryption with the given shared secret.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Data to encrypt.</p> required <code>shared_secret</code> <code>bytes</code> <p>Shared secret used for encryption.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Encrypted data (ciphertext).</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef encrypt_data(data: bytes, shared_secret: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypts data using AES encryption with the given shared secret.\n\n    Args:\n        data (bytes): Data to encrypt.\n        shared_secret (bytes): Shared secret used for encryption.\n\n    Returns:\n        bytes: Encrypted data (ciphertext).\n    \"\"\"\n    ciphertext = AESHelper(shared_secret).encrypt(data)\n    return ciphertext\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.generate_key_pair","title":"<code>generate_key_pair(out_format=KeyFormat.OBJECT)</code>  <code>staticmethod</code>","text":"<pre><code>generate_key_pair(out_format: Literal[KeyFormat.OBJECT, 0]) -&gt; KeyPairObjects\n</code></pre><pre><code>generate_key_pair(out_format: Literal[KeyFormat.BYTE, 1]) -&gt; KeyPairBytes\n</code></pre><pre><code>generate_key_pair(out_format: Literal[KeyFormat.STRING, 2]) -&gt; KeyPairStrings\n</code></pre> <p>Generates an elliptic curve key pair in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>out_format</code> <code>KeyFormat | int</code> <p>Desired output format for the key pair (OBJECT, BYTE, STRING).</p> <code>OBJECT</code> <p>Returns:</p> Name Type Description <code>TKeyPair</code> <code>TKeyPair</code> <p>Key pair in the specified format.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef generate_key_pair(out_format: KeyFormat | int = KeyFormat.OBJECT) -&gt; TKeyPair:\n    \"\"\"\n    Generates an elliptic curve key pair in the specified format.\n\n    Args:\n        out_format (KeyFormat | int): Desired output format for the key pair (OBJECT, BYTE, STRING).\n\n    Returns:\n        TKeyPair: Key pair in the specified format.\n    \"\"\"\n    if out_format not in [KeyFormat.BYTE, KeyFormat.STRING, KeyFormat.OBJECT]:\n        out_format = KeyFormat.OBJECT\n\n    private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())\n    public_key = private_key.public_key()\n\n    if out_format == KeyFormat.BYTE:\n        return KeyPairBytes(\n            ECDHHelper.serialize_private_key(private_key, return_type=bytes),\n            ECDHHelper.serialize_public_key(public_key, return_type=bytes),\n        )\n    elif out_format == KeyFormat.STRING:\n        return KeyPairStrings(\n            ECDHHelper.serialize_private_key(private_key, return_type=str),\n            ECDHHelper.serialize_public_key(public_key, return_type=str),\n        )\n    elif out_format == KeyFormat.OBJECT:\n        return KeyPairObjects(private_key, public_key)\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.generate_shared_secret","title":"<code>generate_shared_secret(private_key, public_key)</code>  <code>staticmethod</code>","text":"<p>Generates a shared secret using ECDH key exchange.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>EllipticCurvePrivateKey</code> <p>Elliptic curve private key.</p> required <code>public_key</code> <code>EllipticCurvePublicKey</code> <p>Elliptic curve public key.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Shared secret bytes.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef generate_shared_secret(\n    private_key: ec.EllipticCurvePrivateKey,\n    public_key: ec.EllipticCurvePublicKey,\n) -&gt; bytes:\n    \"\"\"\n    Generates a shared secret using ECDH key exchange.\n\n    Args:\n        private_key (ec.EllipticCurvePrivateKey): Elliptic curve private key.\n        public_key (ec.EllipticCurvePublicKey): Elliptic curve public key.\n\n    Returns:\n        bytes: Shared secret bytes.\n    \"\"\"\n    shared_secret = private_key.exchange(ec.ECDH(), public_key)\n    return shared_secret\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.serialize_private_key","title":"<code>serialize_private_key(private_key, return_type=bytes)</code>  <code>staticmethod</code>","text":"<p>Serializes a private key to PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>EllipticCurvePrivateKey</code> <p>Elliptic curve private key.</p> required <code>return_type</code> <code>type[StrBytes]</code> <p>Whether to return the serialized key as a string or bytes.</p> <code>bytes</code> <p>Returns:</p> Name Type Description <code>StrBytes</code> <code>StrBytes</code> <p>Serialized private key in PEM format.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef serialize_private_key(\n    private_key: ec.EllipticCurvePrivateKey,\n    return_type: type[StrBytes] = bytes,\n) -&gt; StrBytes:\n    \"\"\"\n    Serializes a private key to PEM format.\n\n    Args:\n        private_key (ec.EllipticCurvePrivateKey): Elliptic curve private key.\n        return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes.\n\n    Returns:\n        StrBytes: Serialized private key in PEM format.\n    \"\"\"\n    key = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption(),\n    )\n    return key.decode() if return_type is str else key\n</code></pre>"},{"location":"api/helpers/#helpers.ecdh.ECDHHelper.serialize_public_key","title":"<code>serialize_public_key(public_key, return_type=bytes)</code>  <code>staticmethod</code>","text":"<p>Serializes a public key to PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>EllipticCurvePublicKey</code> <p>Elliptic curve public key.</p> required <code>return_type</code> <code>type[StrBytes]</code> <p>Whether to return the serialized key as a string or bytes.</p> <code>bytes</code> <p>Returns:</p> Name Type Description <code>StrBytes</code> <code>StrBytes</code> <p>Serialized public key in PEM format.</p> Source code in <code>helpers/ecdh.py</code> <pre><code>@staticmethod\ndef serialize_public_key(\n    public_key: ec.EllipticCurvePublicKey,\n    return_type: type[StrBytes] = bytes,\n) -&gt; StrBytes:\n    \"\"\"\n    Serializes a public key to PEM format.\n\n    Args:\n        public_key (ec.EllipticCurvePublicKey): Elliptic curve public key.\n        return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes.\n\n    Returns:\n        StrBytes: Serialized public key in PEM format.\n    \"\"\"\n    key = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo,\n    )\n    return key.decode() if return_type is str else key\n</code></pre>"},{"location":"api/helpers/#helpersjwt_token","title":"helpers.jwt_token","text":""},{"location":"api/helpers/#helpers.jwt_token","title":"<code>helpers.jwt_token</code>","text":""},{"location":"api/helpers/#helpers.jwt_token.create_access_token","title":"<code>create_access_token(data, expires_delta=timedelta(minutes=JWT_EXPIRE_MINUTES))</code>","text":"<p>Generates a JWT token.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, str]</code> <p>The payload of the JWT token.</p> required <code>expires_delta</code> <code>timedelta</code> <p>The time delta for token expiration. Defaults to timedelta(minutes=JWT_EXPIRE_MINUTES).</p> <code>timedelta(minutes=JWT_EXPIRE_MINUTES)</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated JWT token.</p> Source code in <code>helpers/jwt_token.py</code> <pre><code>def create_access_token(\n    data: dict[str, str], expires_delta: timedelta = timedelta(minutes=JWT_EXPIRE_MINUTES)\n) -&gt; str:\n    \"\"\"Generates a JWT token.\n\n    Args:\n        data (dict[str, str]): The payload of the JWT token.\n        expires_delta (timedelta, optional): The time delta for token expiration. Defaults to timedelta(minutes=JWT_EXPIRE_MINUTES).\n\n    Returns:\n        str: The generated JWT token.\n    \"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(tz=timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(tz=timezone.utc) + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)\n</code></pre>"},{"location":"api/helpers/#helpers.jwt_token.decode_access_token","title":"<code>decode_access_token(token)</code>","text":"<p>Decodes and validates a JWT token. Returns the username and password.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to decode.</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: A tuple containing the username and password.</p> Source code in <code>helpers/jwt_token.py</code> <pre><code>def decode_access_token(token: str) -&gt; tuple[str, str]:\n    \"\"\"Decodes and validates a JWT token. Returns the username and password.\n\n    Args:\n        token (str): The JWT token to decode.\n\n    Returns:\n        tuple[str, str]: A tuple containing the username and password.\n    \"\"\"\n    try:\n        payload: dict[str, str] = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])\n        username: str = payload.get(\"username\")\n        password: str = payload.get(\"password\")\n        if username is None:\n            raise _get_exception(\"Invalid token payload\")\n        return username, password\n    except jwt.ExpiredSignatureError:\n        raise _get_exception(\"Token has expired\")\n    except jwt.exceptions.PyJWTError:\n        raise _get_exception(\"Invalid token\")\n</code></pre>"},{"location":"api/helpers/#helpersrsa","title":"helpers.rsa","text":""},{"location":"api/helpers/#helpers.rsa","title":"<code>helpers.rsa</code>","text":"<p>This module provides a class for RSA key exchange operations, including key pair generation, serialization/deserialization of keys, and data encryption/decryption.</p>"},{"location":"api/helpers/#helpers.rsa.RSAHelper","title":"<code>RSAHelper</code>","text":"<p>Helper class for RSA key exchange operations, including key pair generation, serialization/deserialization of keys, and data encryption/decryption.</p> Source code in <code>helpers/rsa.py</code> <pre><code>class RSAHelper:\n    \"\"\"\n    Helper class for RSA key exchange operations, including key pair generation,\n    serialization/deserialization of keys, and data encryption/decryption.\n    \"\"\"\n\n    @staticmethod\n    @overload\n    def generate_key_pair(out_format: Literal[KeyFormat.OBJECT, 0]) -&gt; KeyPairObjects:\n        ...\n\n    @staticmethod\n    @overload\n    def generate_key_pair(out_format: Literal[KeyFormat.BYTE, 1]) -&gt; KeyPairBytes:\n        ...\n\n    @staticmethod\n    @overload\n    def generate_key_pair(out_format: Literal[KeyFormat.STRING, 2]) -&gt; KeyPairStrings:\n        ...\n\n    @staticmethod\n    def generate_key_pair(out_format: KeyFormat | int = KeyFormat.OBJECT) -&gt; TKeyPair:\n        \"\"\"\n        Generates an RSA key pair in the specified format.\n\n        Args:\n            out_format (KeyFormat): Desired output format for the key pair (OBJECT, BYTE, STRING)\n\n        Returns:\n            TKeyPair: Key pair in the specified format\n        \"\"\"\n        if out_format not in [KeyFormat.BYTE, KeyFormat.STRING, KeyFormat.OBJECT]:\n            out_format = KeyFormat.OBJECT\n\n        private_key = rsa.generate_private_key(\n            public_exponent=65537,\n            key_size=2048,\n            backend=default_backend(),\n        )\n        public_key = private_key.public_key()\n\n        if out_format == KeyFormat.BYTE:\n            return KeyPairBytes(\n                RSAHelper.serialize_private_key(private_key, return_type=bytes),\n                RSAHelper.serialize_public_key(public_key, return_type=bytes),\n            )\n        elif out_format == KeyFormat.STRING:\n            return KeyPairStrings(\n                RSAHelper.serialize_private_key(private_key, return_type=str),\n                RSAHelper.serialize_public_key(public_key, return_type=str),\n            )\n        elif out_format == KeyFormat.OBJECT:\n            return KeyPairObjects(private_key, public_key)\n\n    @staticmethod\n    def serialize_private_key(private_key: rsa.RSAPrivateKey, return_type: type[StrBytes] = bytes) -&gt; StrBytes:\n        \"\"\"\n        Serializes a private key to PEM format.\n\n        Args:\n            private_key (rsa.RSAPrivateKey): RSA private key\n            return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes\n\n        Returns:\n            StrBytes: Serialized private key in PEM format as a string or bytes\n        \"\"\"\n        key = private_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return key.decode() if return_type is str else key\n\n    @staticmethod\n    def deserialize_private_key(data: bytes | str) -&gt; rsa.RSAPrivateKey:\n        \"\"\"\n        Deserializes a PEM-encoded private key from bytes or hex string.\n\n        Args:\n            data (bytes | str): Serialized private key in bytes or hex string format.\n\n        Returns:\n            rsa.RSAPrivateKey: Elliptic curve private key object.\n        \"\"\"\n        if isinstance(data, str):\n            data = data.encode()\n        try:\n            key = serialization.load_pem_private_key(\n                data, password=None, backend=default_backend()\n            )\n            return key\n        except Exception as e:\n            raise ValueError(f\"Failed to deserialize private key: {e}\")\n\n    @staticmethod\n    def serialize_public_key(public_key: rsa.RSAPublicKey, return_type: type[StrBytes] = bytes) -&gt; StrBytes:\n        \"\"\"\n        Serializes a public key to PEM format.\n\n        Args:\n            public_key (rsa.RSAPublicKey): RSA public key\n            return_type (type[StrBytes]): Desired return type for the serialized key (str or bytes)\n\n        Returns:\n            StrBytes: Serialized public key in PEM format as a string or bytes\n        \"\"\"\n        key = public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        return key.decode() if return_type is str else key\n\n    @staticmethod\n    def deserialize_public_key(data: bytes | str) -&gt; rsa.RSAPublicKey:\n        \"\"\"\n        Deserializes a PEM-encoded public key from bytes or hex string.\n\n        Args:\n            data (bytes | str): Serialized public key in bytes or hex string format\n\n        Returns:\n            rsa.RSAPublicKey: RSA public key object\n        \"\"\"\n        if isinstance(data, str):\n            data = data.encode()\n        try:\n            key = serialization.load_pem_public_key(data, backend=default_backend())\n            return key\n        except Exception as e:\n            raise ValueError(f\"Failed to deserialize public key: {e}\")\n\n    @staticmethod\n    def get_padding() -&gt; padding.OAEP:\n        \"\"\"\n        Returns an OAEP padding object configured with MGF1 using SHA-256\n        as the hash algorithm. This padding is used for RSA encryption\n        to provide additional security measures, such as preventing\n        chosen ciphertext attacks. No label is used in this configuration.\n\n        Returns:\n            padding.OAEP: OAEP padding object configured with MGF1 using SHA-256\n        \"\"\"\n        return padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),  # Mask generation function\n            algorithm=hashes.SHA256(),  # Hash algorithm used for OAEP\n            label=None,  # No label is used\n        )\n\n    @staticmethod\n    def encrypt_data(data: bytes, public_key: rsa.RSAPublicKey | str | bytes) -&gt; bytes:\n        \"\"\"\n        Encrypts data using AES encryption with the given shared secret.\n\n        Args:\n            data (bytes): Data to encrypt\n            public_key (rsa.RSAPublicKey | str | bytes): Public key used for encryption, can be an RSAPublicKey object, a PEM string, or bytes\n\n        Returns:\n            bytes: Encrypted data (ciphertext)\n        \"\"\"\n        if isinstance(public_key, (str, bytes)):\n            public_key = RSAHelper.deserialize_public_key(public_key)\n        ciphertext = public_key.encrypt(data, RSAHelper.get_padding())\n        return ciphertext\n\n    @staticmethod\n    def decrypt_data(\n        ciphertext: bytes, private_key: rsa.RSAPrivateKey | str | bytes\n    ) -&gt; bytes:\n        \"\"\"\n        Decrypt data using AES encryption with the given shared secret.\n\n        Args:\n            ciphertext (bytes): Encrypted data (ciphertext)\n            private_key (rsa.RSAPrivateKey | str | bytes): Private key used for decryption, can be an RSAPrivateKey object, a PEM string, or bytes\n\n        Returns:\n            bytes: Decrypted data\n        \"\"\"\n        if isinstance(private_key, (str, bytes)):\n            private_key = RSAHelper.deserialize_private_key(private_key)\n        data = private_key.decrypt(ciphertext, RSAHelper.get_padding())\n        return data\n\n    @staticmethod\n    def sign_data(data: bytes, private_key: rsa.RSAPrivateKey | str | bytes) -&gt; bytes:\n        \"\"\"\n        Signs the given data using the provided private key.\n\n        Args:\n            data (bytes): Data to be signed\n            private_key (rsa.RSAPrivateKey | str | bytes): Private key used for signing, can be an RSAPrivateKey object, a PEM string, or bytes\n\n        Returns:\n            bytes: The generated signature as bytes\n        \"\"\"\n        if isinstance(private_key, (str, bytes)):\n            private_key = RSAHelper.deserialize_private_key(private_key)\n        signature = private_key.sign(data, RSAHelper.get_padding(), hashes.SHA256())\n        return signature\n\n    @staticmethod\n    def verify_signature(\n        data: bytes, signature: bytes, public_key: rsa.RSAPublicKey | str | bytes\n    ) -&gt; bool:\n        \"\"\"\n        Verifies the given signature against the given data and public key.\n\n        Args:\n            data (bytes): Data that was signed\n            signature (bytes): Signature to verify\n            public_key (rsa.RSAPublicKey | str | bytes): Public key to use for verification, can be an RSAPublicKey object, a PEM string, or bytes\n\n        Returns:\n            bool: True if the signature is valid, False otherwise\n        \"\"\"\n        if isinstance(public_key, (str, bytes)):\n            public_key = RSAHelper.deserialize_public_key(public_key)\n        try:\n            public_key.verify(signature, data, RSAHelper.get_padding(), hashes.SHA256())\n            return True\n        except Exception:\n            return False\n\n    @staticmethod\n    def verify_key_pair(\n        private_key: rsa.RSAPrivateKey | str | bytes,\n        public_key: rsa.RSAPublicKey | str | bytes,\n    ) -&gt; bool:\n        \"\"\"\n        Verifies that the given private and public key are a matching pair.\n\n        Args:\n            private_key (rsa.RSAPrivateKey | str | bytes): Private key to verify, can be an RSAPrivateKey object, a PEM string, or bytes\n            public_key (rsa.RSAPublicKey | str | bytes): Public key to verify, can be an RSAPublicKey object, a PEM string, or bytes\n\n        Returns:\n            bool: True if the key pair is valid, False otherwise\n        \"\"\"\n        if isinstance(private_key, (str, bytes)):\n            private_key = RSAHelper.deserialize_private_key(private_key)\n        if isinstance(public_key, (str, bytes)):\n            public_key = RSAHelper.deserialize_public_key(public_key)\n        return private_key.public_key() == public_key\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.decrypt_data","title":"<code>decrypt_data(ciphertext, private_key)</code>  <code>staticmethod</code>","text":"<p>Decrypt data using AES encryption with the given shared secret.</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes</code> <p>Encrypted data (ciphertext)</p> required <code>private_key</code> <code>RSAPrivateKey | str | bytes</code> <p>Private key used for decryption, can be an RSAPrivateKey object, a PEM string, or bytes</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Decrypted data</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef decrypt_data(\n    ciphertext: bytes, private_key: rsa.RSAPrivateKey | str | bytes\n) -&gt; bytes:\n    \"\"\"\n    Decrypt data using AES encryption with the given shared secret.\n\n    Args:\n        ciphertext (bytes): Encrypted data (ciphertext)\n        private_key (rsa.RSAPrivateKey | str | bytes): Private key used for decryption, can be an RSAPrivateKey object, a PEM string, or bytes\n\n    Returns:\n        bytes: Decrypted data\n    \"\"\"\n    if isinstance(private_key, (str, bytes)):\n        private_key = RSAHelper.deserialize_private_key(private_key)\n    data = private_key.decrypt(ciphertext, RSAHelper.get_padding())\n    return data\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.deserialize_private_key","title":"<code>deserialize_private_key(data)</code>  <code>staticmethod</code>","text":"<p>Deserializes a PEM-encoded private key from bytes or hex string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | str</code> <p>Serialized private key in bytes or hex string format.</p> required <p>Returns:</p> Type Description <code>RSAPrivateKey</code> <p>rsa.RSAPrivateKey: Elliptic curve private key object.</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef deserialize_private_key(data: bytes | str) -&gt; rsa.RSAPrivateKey:\n    \"\"\"\n    Deserializes a PEM-encoded private key from bytes or hex string.\n\n    Args:\n        data (bytes | str): Serialized private key in bytes or hex string format.\n\n    Returns:\n        rsa.RSAPrivateKey: Elliptic curve private key object.\n    \"\"\"\n    if isinstance(data, str):\n        data = data.encode()\n    try:\n        key = serialization.load_pem_private_key(\n            data, password=None, backend=default_backend()\n        )\n        return key\n    except Exception as e:\n        raise ValueError(f\"Failed to deserialize private key: {e}\")\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.deserialize_public_key","title":"<code>deserialize_public_key(data)</code>  <code>staticmethod</code>","text":"<p>Deserializes a PEM-encoded public key from bytes or hex string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes | str</code> <p>Serialized public key in bytes or hex string format</p> required <p>Returns:</p> Type Description <code>RSAPublicKey</code> <p>rsa.RSAPublicKey: RSA public key object</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef deserialize_public_key(data: bytes | str) -&gt; rsa.RSAPublicKey:\n    \"\"\"\n    Deserializes a PEM-encoded public key from bytes or hex string.\n\n    Args:\n        data (bytes | str): Serialized public key in bytes or hex string format\n\n    Returns:\n        rsa.RSAPublicKey: RSA public key object\n    \"\"\"\n    if isinstance(data, str):\n        data = data.encode()\n    try:\n        key = serialization.load_pem_public_key(data, backend=default_backend())\n        return key\n    except Exception as e:\n        raise ValueError(f\"Failed to deserialize public key: {e}\")\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.encrypt_data","title":"<code>encrypt_data(data, public_key)</code>  <code>staticmethod</code>","text":"<p>Encrypts data using AES encryption with the given shared secret.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Data to encrypt</p> required <code>public_key</code> <code>RSAPublicKey | str | bytes</code> <p>Public key used for encryption, can be an RSAPublicKey object, a PEM string, or bytes</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Encrypted data (ciphertext)</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef encrypt_data(data: bytes, public_key: rsa.RSAPublicKey | str | bytes) -&gt; bytes:\n    \"\"\"\n    Encrypts data using AES encryption with the given shared secret.\n\n    Args:\n        data (bytes): Data to encrypt\n        public_key (rsa.RSAPublicKey | str | bytes): Public key used for encryption, can be an RSAPublicKey object, a PEM string, or bytes\n\n    Returns:\n        bytes: Encrypted data (ciphertext)\n    \"\"\"\n    if isinstance(public_key, (str, bytes)):\n        public_key = RSAHelper.deserialize_public_key(public_key)\n    ciphertext = public_key.encrypt(data, RSAHelper.get_padding())\n    return ciphertext\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.generate_key_pair","title":"<code>generate_key_pair(out_format=KeyFormat.OBJECT)</code>  <code>staticmethod</code>","text":"<pre><code>generate_key_pair(out_format: Literal[KeyFormat.OBJECT, 0]) -&gt; KeyPairObjects\n</code></pre><pre><code>generate_key_pair(out_format: Literal[KeyFormat.BYTE, 1]) -&gt; KeyPairBytes\n</code></pre><pre><code>generate_key_pair(out_format: Literal[KeyFormat.STRING, 2]) -&gt; KeyPairStrings\n</code></pre> <p>Generates an RSA key pair in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>out_format</code> <code>KeyFormat</code> <p>Desired output format for the key pair (OBJECT, BYTE, STRING)</p> <code>OBJECT</code> <p>Returns:</p> Name Type Description <code>TKeyPair</code> <code>TKeyPair</code> <p>Key pair in the specified format</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef generate_key_pair(out_format: KeyFormat | int = KeyFormat.OBJECT) -&gt; TKeyPair:\n    \"\"\"\n    Generates an RSA key pair in the specified format.\n\n    Args:\n        out_format (KeyFormat): Desired output format for the key pair (OBJECT, BYTE, STRING)\n\n    Returns:\n        TKeyPair: Key pair in the specified format\n    \"\"\"\n    if out_format not in [KeyFormat.BYTE, KeyFormat.STRING, KeyFormat.OBJECT]:\n        out_format = KeyFormat.OBJECT\n\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend(),\n    )\n    public_key = private_key.public_key()\n\n    if out_format == KeyFormat.BYTE:\n        return KeyPairBytes(\n            RSAHelper.serialize_private_key(private_key, return_type=bytes),\n            RSAHelper.serialize_public_key(public_key, return_type=bytes),\n        )\n    elif out_format == KeyFormat.STRING:\n        return KeyPairStrings(\n            RSAHelper.serialize_private_key(private_key, return_type=str),\n            RSAHelper.serialize_public_key(public_key, return_type=str),\n        )\n    elif out_format == KeyFormat.OBJECT:\n        return KeyPairObjects(private_key, public_key)\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.get_padding","title":"<code>get_padding()</code>  <code>staticmethod</code>","text":"<p>Returns an OAEP padding object configured with MGF1 using SHA-256 as the hash algorithm. This padding is used for RSA encryption to provide additional security measures, such as preventing chosen ciphertext attacks. No label is used in this configuration.</p> <p>Returns:</p> Type Description <code>OAEP</code> <p>padding.OAEP: OAEP padding object configured with MGF1 using SHA-256</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef get_padding() -&gt; padding.OAEP:\n    \"\"\"\n    Returns an OAEP padding object configured with MGF1 using SHA-256\n    as the hash algorithm. This padding is used for RSA encryption\n    to provide additional security measures, such as preventing\n    chosen ciphertext attacks. No label is used in this configuration.\n\n    Returns:\n        padding.OAEP: OAEP padding object configured with MGF1 using SHA-256\n    \"\"\"\n    return padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),  # Mask generation function\n        algorithm=hashes.SHA256(),  # Hash algorithm used for OAEP\n        label=None,  # No label is used\n    )\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.serialize_private_key","title":"<code>serialize_private_key(private_key, return_type=bytes)</code>  <code>staticmethod</code>","text":"<p>Serializes a private key to PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>RSAPrivateKey</code> <p>RSA private key</p> required <code>return_type</code> <code>type[StrBytes]</code> <p>Whether to return the serialized key as a string or bytes</p> <code>bytes</code> <p>Returns:</p> Name Type Description <code>StrBytes</code> <code>StrBytes</code> <p>Serialized private key in PEM format as a string or bytes</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef serialize_private_key(private_key: rsa.RSAPrivateKey, return_type: type[StrBytes] = bytes) -&gt; StrBytes:\n    \"\"\"\n    Serializes a private key to PEM format.\n\n    Args:\n        private_key (rsa.RSAPrivateKey): RSA private key\n        return_type (type[StrBytes]): Whether to return the serialized key as a string or bytes\n\n    Returns:\n        StrBytes: Serialized private key in PEM format as a string or bytes\n    \"\"\"\n    key = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption(),\n    )\n    return key.decode() if return_type is str else key\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.serialize_public_key","title":"<code>serialize_public_key(public_key, return_type=bytes)</code>  <code>staticmethod</code>","text":"<p>Serializes a public key to PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>RSAPublicKey</code> <p>RSA public key</p> required <code>return_type</code> <code>type[StrBytes]</code> <p>Desired return type for the serialized key (str or bytes)</p> <code>bytes</code> <p>Returns:</p> Name Type Description <code>StrBytes</code> <code>StrBytes</code> <p>Serialized public key in PEM format as a string or bytes</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef serialize_public_key(public_key: rsa.RSAPublicKey, return_type: type[StrBytes] = bytes) -&gt; StrBytes:\n    \"\"\"\n    Serializes a public key to PEM format.\n\n    Args:\n        public_key (rsa.RSAPublicKey): RSA public key\n        return_type (type[StrBytes]): Desired return type for the serialized key (str or bytes)\n\n    Returns:\n        StrBytes: Serialized public key in PEM format as a string or bytes\n    \"\"\"\n    key = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo,\n    )\n    return key.decode() if return_type is str else key\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.sign_data","title":"<code>sign_data(data, private_key)</code>  <code>staticmethod</code>","text":"<p>Signs the given data using the provided private key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Data to be signed</p> required <code>private_key</code> <code>RSAPrivateKey | str | bytes</code> <p>Private key used for signing, can be an RSAPrivateKey object, a PEM string, or bytes</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The generated signature as bytes</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef sign_data(data: bytes, private_key: rsa.RSAPrivateKey | str | bytes) -&gt; bytes:\n    \"\"\"\n    Signs the given data using the provided private key.\n\n    Args:\n        data (bytes): Data to be signed\n        private_key (rsa.RSAPrivateKey | str | bytes): Private key used for signing, can be an RSAPrivateKey object, a PEM string, or bytes\n\n    Returns:\n        bytes: The generated signature as bytes\n    \"\"\"\n    if isinstance(private_key, (str, bytes)):\n        private_key = RSAHelper.deserialize_private_key(private_key)\n    signature = private_key.sign(data, RSAHelper.get_padding(), hashes.SHA256())\n    return signature\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.verify_key_pair","title":"<code>verify_key_pair(private_key, public_key)</code>  <code>staticmethod</code>","text":"<p>Verifies that the given private and public key are a matching pair.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>RSAPrivateKey | str | bytes</code> <p>Private key to verify, can be an RSAPrivateKey object, a PEM string, or bytes</p> required <code>public_key</code> <code>RSAPublicKey | str | bytes</code> <p>Public key to verify, can be an RSAPublicKey object, a PEM string, or bytes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key pair is valid, False otherwise</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef verify_key_pair(\n    private_key: rsa.RSAPrivateKey | str | bytes,\n    public_key: rsa.RSAPublicKey | str | bytes,\n) -&gt; bool:\n    \"\"\"\n    Verifies that the given private and public key are a matching pair.\n\n    Args:\n        private_key (rsa.RSAPrivateKey | str | bytes): Private key to verify, can be an RSAPrivateKey object, a PEM string, or bytes\n        public_key (rsa.RSAPublicKey | str | bytes): Public key to verify, can be an RSAPublicKey object, a PEM string, or bytes\n\n    Returns:\n        bool: True if the key pair is valid, False otherwise\n    \"\"\"\n    if isinstance(private_key, (str, bytes)):\n        private_key = RSAHelper.deserialize_private_key(private_key)\n    if isinstance(public_key, (str, bytes)):\n        public_key = RSAHelper.deserialize_public_key(public_key)\n    return private_key.public_key() == public_key\n</code></pre>"},{"location":"api/helpers/#helpers.rsa.RSAHelper.verify_signature","title":"<code>verify_signature(data, signature, public_key)</code>  <code>staticmethod</code>","text":"<p>Verifies the given signature against the given data and public key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Data that was signed</p> required <code>signature</code> <code>bytes</code> <p>Signature to verify</p> required <code>public_key</code> <code>RSAPublicKey | str | bytes</code> <p>Public key to use for verification, can be an RSAPublicKey object, a PEM string, or bytes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>helpers/rsa.py</code> <pre><code>@staticmethod\ndef verify_signature(\n    data: bytes, signature: bytes, public_key: rsa.RSAPublicKey | str | bytes\n) -&gt; bool:\n    \"\"\"\n    Verifies the given signature against the given data and public key.\n\n    Args:\n        data (bytes): Data that was signed\n        signature (bytes): Signature to verify\n        public_key (rsa.RSAPublicKey | str | bytes): Public key to use for verification, can be an RSAPublicKey object, a PEM string, or bytes\n\n    Returns:\n        bool: True if the signature is valid, False otherwise\n    \"\"\"\n    if isinstance(public_key, (str, bytes)):\n        public_key = RSAHelper.deserialize_public_key(public_key)\n    try:\n        public_key.verify(signature, data, RSAHelper.get_padding(), hashes.SHA256())\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/helpers/#helpersutils","title":"helpers.utils","text":""},{"location":"api/helpers/#helpers.utils","title":"<code>helpers.utils</code>","text":""},{"location":"api/helpers/#helpers.utils.hash_bytes","title":"<code>hash_bytes(data, algorithm='sha256', return_type=uuid.UUID)</code>","text":"<p>Calculate the hash of the given bytes using the specified algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to be hashed.</p> required <code>algorithm</code> <code>str</code> <p>Hashing algorithm to use (default is 'sha256').              Options include 'md5', 'sha1', 'sha256', 'sha512', etc.</p> <code>'sha256'</code> <code>return_type</code> <code>type[str | UUID]</code> <p>Type to return the hash as (default is uuid.UUID).</p> <code>UUID</code> <p>Returns:</p> Type Description <code>StrUuid</code> <p>str | uuid.UUID: The hash of the data as a string or UUID.</p> Source code in <code>helpers/utils.py</code> <pre><code>def hash_bytes(\n    data: bytes, algorithm=\"sha256\", return_type: type[StrUuid] = uuid.UUID\n) -&gt; StrUuid:\n    \"\"\"\n    Calculate the hash of the given bytes using the specified algorithm.\n\n    Args:\n        data (bytes): The data to be hashed.\n        algorithm (str): Hashing algorithm to use (default is 'sha256').\n                         Options include 'md5', 'sha1', 'sha256', 'sha512', etc.\n        return_type (type[str | uuid.UUID]): Type to return the hash as (default is uuid.UUID).\n\n    Returns:\n        str | uuid.UUID: The hash of the data as a string or UUID.\n    \"\"\"\n\n    return hash_file(data, algorithm, return_type)\n</code></pre>"},{"location":"api/helpers/#helpers.utils.hash_file","title":"<code>hash_file(file, algorithm='sha256', return_type=uuid.UUID)</code>","text":"<p>Calculate the hash of a file or its contents.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | bytes</code> <p>Path to the file or contents of the file as bytes.</p> required <code>algorithm</code> <code>str</code> <p>Hashing algorithm (default is 'sha256').              Options include 'md5', 'sha1', 'sha256', 'sha512', etc.</p> <code>'sha256'</code> <code>return_type</code> <code>type[str | UUID]</code> <p>Type to return the hash as (default is uuid.UUID).</p> <code>UUID</code> <p>Returns:</p> Type Description <code>StrUuid</code> <p>str | uuid.UUID: The hash of the file or its contents as a string or UUID.</p> Source code in <code>helpers/utils.py</code> <pre><code>def hash_file(\n    file: str | Path | bytes, algorithm=\"sha256\", return_type: type[StrUuid] = uuid.UUID\n) -&gt; StrUuid:\n    \"\"\"\n    Calculate the hash of a file or its contents.\n\n    Args:\n        file (str  | Path | bytes): Path to the file or contents of the file as bytes.\n        algorithm (str): Hashing algorithm (default is 'sha256').\n                         Options include 'md5', 'sha1', 'sha256', 'sha512', etc.\n        return_type (type[str | uuid.UUID]): Type to return the hash as (default is uuid.UUID).\n\n    Returns:\n        str | uuid.UUID: The hash of the file or its contents as a string or UUID.\n    \"\"\"\n    hash_func = hashlib.new(algorithm)\n    buffer_size = 65536  # Read in chunks of 64 KB\n\n    if isinstance(file, (str, Path)):\n        if not Path(file).exists():\n            raise FileNotFoundError(\n                f\"The file '{file}' does not exist in the local file system.\"\n            )\n        file_reader = open(file, \"rb\")\n    else:\n        file_reader = BytesIO(file)\n\n    try:\n        while chunk := file_reader.read(buffer_size):\n            hash_func.update(chunk)\n        _hash = hash_func.hexdigest()\n        if return_type == uuid.UUID:\n            return hash_text(_hash)\n        return _hash\n    finally:\n        file_reader.close()\n</code></pre>"},{"location":"api/helpers/#helpers.utils.hash_text","title":"<code>hash_text(text, base_uuid=None)</code>","text":"<p>Generates a hash-based UUID using the given text and an optional base UUID.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be used for generating the hash-based UUID.</p> required <code>base_uuid</code> <code>UUID | None</code> <p>The optional base UUID to use for hashing. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>uuid.UUID: The hash-based UUID generated from the input text and base UUID.</p> Source code in <code>helpers/utils.py</code> <pre><code>def hash_text(text: str, base_uuid: uuid.UUID | None = None):\n    \"\"\"\n    Generates a hash-based UUID using the given text and an optional base UUID.\n\n    Args:\n        text (str): The text to be used for generating the hash-based UUID.\n        base_uuid (uuid.UUID | None, optional): The optional base UUID to use for hashing. Defaults to None.\n\n    Returns:\n        uuid.UUID: The hash-based UUID generated from the input text and base UUID.\n    \"\"\"\n    if not isinstance(base_uuid, uuid.UUID):\n        base_uuid = uuid.NAMESPACE_DNS\n    return uuid.uuid3(base_uuid, text)\n</code></pre>"},{"location":"api/helpers/#helpers.utils.slugify","title":"<code>slugify(text, replace_specials_with='_', replace_spaces_with='-')</code>","text":"<p>Convert a given string into a slug format.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to be converted into a slug.</p> required <code>replace_specials_with</code> <code>str</code> <p>The character to replace special characters with. Defaults to \"_.</p> <code>'_'</code> <code>replace_spaces_with</code> <code>str</code> <p>The character to replace spaces with. Defaults to \"-\".</p> <code>'-'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The slugified string.</p> Source code in <code>helpers/utils.py</code> <pre><code>def slugify(\n    text: str, replace_specials_with: str = \"_\", replace_spaces_with: str = \"-\"\n) -&gt; str:\n    \"\"\"\n    Convert a given string into a slug format.\n\n    Args:\n        text (str): The string to be converted into a slug.\n        replace_specials_with (str, optional): The character to replace special characters with. Defaults to \"_.\n        replace_spaces_with (str, optional): The character to replace spaces with. Defaults to \"-\".\n\n    Returns:\n        str: The slugified string.\n    \"\"\"\n    return (\n        re.sub(r\"[^\\w\\s-]+\", replace_specials_with, text)\n        .strip()\n        .lower()\n        .replace(\" \", replace_spaces_with)\n    )\n</code></pre>"},{"location":"api/logic/","title":"Logic","text":""},{"location":"api/logic/#logicdeps","title":"logic.deps","text":""},{"location":"api/logic/#logic.deps","title":"<code>logic.deps</code>","text":""},{"location":"api/logic/#logic.deps.get_current_user","title":"<code>get_current_user(token=Depends(oauth2_scheme))</code>","text":"<p>Retrieves the current user from the token.</p> Source code in <code>logic/deps.py</code> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Retrieves the current user from the token.\"\"\"\n    username, password = decode_access_token(token)\n    user = User.get(username)\n    if not user or not user.verify_password(password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid user\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    private_key = user.get_private_key(password)\n    return UserWithPrivateKey(user=user, private_key=private_key)\n</code></pre>"},{"location":"api/models/","title":"Models","text":""},{"location":"api/models/#modelsbase","title":"models.base","text":""},{"location":"api/models/#models.base","title":"<code>models.base</code>","text":""},{"location":"api/models/#modelsdocument","title":"models.document","text":""},{"location":"api/models/#models.document","title":"<code>models.document</code>","text":""},{"location":"api/models/#models.document.Document","title":"<code>Document</code>","text":"<p>               Bases: <code>SQLModelWithID</code>, <code>DocumentCommon</code></p> <p>A document is a file that can be accessed by the users of the system. Each document has a unique ID, filepath, content, and owner. The owner is the user who originally uploaded the document.</p> <p>The document is stored in the file system, and the filepath is used to identify the document. The content of the document is encrypted using the Data Encryption Key (DEK) before it is stored in the file system.</p> <p>Each document has a list of users who have access to the document. The access is granted using the User ID of the users. The users with access to the document can download the document.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the document.</p> <code>filepath</code> <code>str</code> <p>The filepath of the document in the file system.</p> <code>content</code> <code>bytes</code> <p>The content of the document in bytes.</p> <code>owner_id</code> <code>str</code> <p>The User ID of the owner of the document.</p> <code>shared_keys</code> <code>list[SharedKeyRegistry]</code> <p>A list of SharedKeyRegistry objects that store the shared encryption keys for the document.</p> <code>uploaded_on</code> <code>datetime</code> <p>The timestamp when the document was uploaded.</p> Source code in <code>models/document.py</code> <pre><code>class Document(SQLModelWithID, DocumentCommon, table=True):\n    \"\"\"\n    A document is a file that can be accessed by the users of the system. Each\n    document has a unique ID, filepath, content, and owner. The owner is the\n    user who originally uploaded the document.\n\n    The document is stored in the file system, and the filepath is used to\n    identify the document. The content of the document is encrypted using the\n    Data Encryption Key (DEK) before it is stored in the file system.\n\n    Each document has a list of users who have access to the document. The\n    access is granted using the User ID of the users. The users with access\n    to the document can download the document.\n\n    Attributes:\n        id (str): Unique identifier for the document.\n        filepath (str): The filepath of the document in the file system.\n        content (bytes): The content of the document in bytes.\n        owner_id (str): The User ID of the owner of the document.\n        shared_keys (list[SharedKeyRegistry]): A list of SharedKeyRegistry\n            objects that store the shared encryption keys for the document.\n        uploaded_on (datetime): The timestamp when the document was uploaded.\n    \"\"\"\n    id: str = Field(default_factory=lambda: uuid.uuid4().hex, primary_key=True)\n    hash: str\n    uploaded_on: datetime = Field(default_factory=lambda: datetime.now(tz=timezone.utc))\n    shared_keys: list[SharedKeyRegistry] = Relationship(\n        back_populates=\"document\",\n        sa_relationship_kwargs={\"primaryjoin\": \"SharedKeyRegistry.document_id == Document.id\"},\n        cascade_delete=True,\n    )\n\n    @property\n    def local_path(self) -&gt; str:\n        return f\"{self.id}.bin\"\n\n    def write_content(self, content: bytes):\n        DOCUMENT_STORE.write(self.local_path, content)\n\n    def get_content(self):\n        return DOCUMENT_STORE.read(self.local_path)\n\n    def update_shared_keys_registry(self, user_ids: list[str], dek: bytes):\n        \"\"\"\n        Updates the shared keys registry for the given users.\n\n        This function updates the SharedKeyRegistry table with the given user\n        IDs and the Data Encryption Key (DEK) for the document. The DEK is\n        encrypted using the public key of each user and stored in the\n        SharedKeyRegistry table.\n\n        Args:\n            user_ids (list[str]): A list of User IDs to update the shared\n                keys registry for.\n            dek (bytes): The Data Encryption Key (DEK) to store in the\n                SharedKeyRegistry table. The DEK is encrypted using the\n                public key of each user before it is stored.\n        \"\"\"\n        user_id_obj_map = User.get_id_obj_map(user_ids)\n        for user_id, user in user_id_obj_map.items():\n            shared_key = SharedKeyRegistry(\n                user_id=user_id,\n                document_id=str(self.id),\n                shared_key=RSA.encrypt_data(dek, user.public_key),\n            )\n            shared_key.upsert()\n\n    def get_dek(self, user_id: str, user_private_key: bytes):\n        \"\"\"\n        Get the DEK for the given user_id, using the private key provided.\n\n        Args:\n            user_id (str): The ID of the user.\n            user_private_key (bytes): The user's private key.\n\n        Returns:\n            bytes: The DEK for the document.\n\n        Raises:\n            ValueError: If the document is not shared with the user or if the\n                private key is invalid.\n        \"\"\"\n        with Session(getEngine()) as db:\n            rows = db.exec(\n                select(SharedKeyRegistry)\n                .where(\n                    SharedKeyRegistry.document_id == self.id,\n                    SharedKeyRegistry.user_id == user_id,\n                )\n            ).all()\n        if len(rows) == 0:\n            raise ValueError(f\"Document({self.id}) not shared with User({user_id})\")\n        try:\n            return RSA.decrypt_data(rows[-1].shared_key, user_private_key)\n        except Exception:\n            raise ValueError(f\"Invalid private key for User({user_id})\")\n\n    @classmethod\n    def from_base(cls, document: DocumentBase):\n        return cls.upload(document)\n\n    def _to_share_response(self, user_ids: list[str]):\n        return DocumentShareResponse(\n            id=self.id,\n            filepath=self.filepath,\n            owner_id=self.owner_id,\n            uploaded_on=self.uploaded_on,\n            shared_with=self.shared_with,\n            not_shared_with=list(set(user_ids) - set(self.shared_with)),\n        )\n\n    @classmethod\n    def upload(cls, document: DocumentBase):\n        owner_id = document.owner_id\n        if User.get_by_id(owner_id) is None:\n            raise ValueError(f\"User ({owner_id}) not found\")\n\n        file_hash = hash_file(document.content, return_type=str)\n        doc_id = hash_text(f\"{owner_id}-{document.filepath}-{file_hash}\").hex\n\n        # Check if document already exists (maybe use hash and/or filepath)\n        record = Document.get_by_id(doc_id)\n        if record is not None:\n            return record._to_share_response(document.share_with)\n\n        dek = AES.get_random_key()\n        encrypted_content = AES(dek).encrypt(document.content)\n        doc = Document(\n            id=hash_text(f\"{owner_id}-{document.filepath}-{file_hash}\").hex,\n            filepath=document.filepath,\n            owner_id=owner_id,\n            hash=file_hash,\n        ).create()\n        doc.update_shared_keys_registry([owner_id, *document.share_with], dek)\n        doc.write_content(encrypted_content)\n        return doc._to_share_response(document.share_with)\n\n    def share(self, user_ids: list[str], owner_private_key: bytes) -&gt; DocumentShareResponse:\n        dek = self.get_dek(self.owner_id, owner_private_key)\n        self.update_shared_keys_registry(user_ids, dek)\n        return self._to_share_response(user_ids)\n\n    def revoke_access(self, user_ids: list[str], owner_private_key: bytes) -&gt; DocumentShareResponse:\n        # This checks if the user is the owner\n        dek = self.get_dek(self.owner_id, owner_private_key)  # noqa: F841\n\n        if self.owner_id in user_ids:\n            raise ValueError(\"Cannot revoke access to the owner\")\n        with Session(getEngine()) as db:\n            rows = db.exec(\n                select(SharedKeyRegistry)\n                .where(\n                    SharedKeyRegistry.document_id == self.id,\n                    SharedKeyRegistry.user_id.in_(user_ids),\n                )\n            ).all()\n        for row in rows:\n            SharedKeyRegistry.delete(row)\n\n        return self._to_share_response(user_ids)\n\n    def download(self, user_id: str, user_private_key: bytes):\n        dek = self.get_dek(user_id, user_private_key)\n        content = self.get_content()\n        return DocumentDownloadResponse(\n            filepath=self.filepath,\n            content=AES(dek).decrypt(content),\n            owner_id=self.owner_id,\n        )\n\n    def delete(self):\n        # Delete the document from the document store\n        DOCUMENT_STORE.delete(self.filepath)\n\n        # Delete the shared keys\n        with Session(getEngine()) as db:\n            rows = db.exec(\n                select(SharedKeyRegistry)\n                .where(\n                    SharedKeyRegistry.document_id == self.id,\n                )\n            ).all()\n            for row in rows:\n                SharedKeyRegistry.delete(row)\n\n        # Delete the document itself\n        super().delete()\n\n    @property\n    def shared_with(self):\n        with Session(getEngine()) as db:\n            rows = db.exec(\n                select(SharedKeyRegistry)\n                .where(\n                    SharedKeyRegistry.document_id == self.id,\n                )\n            ).all()\n        return [row.user_id for row in rows]\n\n    @classmethod\n    def get_shared_documents(cls, user_id: str):\n        with Session(getEngine()) as db:\n            rows = db.exec(\n                select(SharedKeyRegistry)\n                .where(\n                    SharedKeyRegistry.user_id == user_id,\n                )\n            ).all()\n        return list(cls.get_by_ids([row.document_id for row in rows]))\n</code></pre>"},{"location":"api/models/#models.document.Document.get_dek","title":"<code>get_dek(user_id, user_private_key)</code>","text":"<p>Get the DEK for the given user_id, using the private key provided.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user.</p> required <code>user_private_key</code> <code>bytes</code> <p>The user's private key.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>The DEK for the document.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the document is not shared with the user or if the private key is invalid.</p> Source code in <code>models/document.py</code> <pre><code>def get_dek(self, user_id: str, user_private_key: bytes):\n    \"\"\"\n    Get the DEK for the given user_id, using the private key provided.\n\n    Args:\n        user_id (str): The ID of the user.\n        user_private_key (bytes): The user's private key.\n\n    Returns:\n        bytes: The DEK for the document.\n\n    Raises:\n        ValueError: If the document is not shared with the user or if the\n            private key is invalid.\n    \"\"\"\n    with Session(getEngine()) as db:\n        rows = db.exec(\n            select(SharedKeyRegistry)\n            .where(\n                SharedKeyRegistry.document_id == self.id,\n                SharedKeyRegistry.user_id == user_id,\n            )\n        ).all()\n    if len(rows) == 0:\n        raise ValueError(f\"Document({self.id}) not shared with User({user_id})\")\n    try:\n        return RSA.decrypt_data(rows[-1].shared_key, user_private_key)\n    except Exception:\n        raise ValueError(f\"Invalid private key for User({user_id})\")\n</code></pre>"},{"location":"api/models/#models.document.Document.update_shared_keys_registry","title":"<code>update_shared_keys_registry(user_ids, dek)</code>","text":"<p>Updates the shared keys registry for the given users.</p> <p>This function updates the SharedKeyRegistry table with the given user IDs and the Data Encryption Key (DEK) for the document. The DEK is encrypted using the public key of each user and stored in the SharedKeyRegistry table.</p> <p>Parameters:</p> Name Type Description Default <code>user_ids</code> <code>list[str]</code> <p>A list of User IDs to update the shared keys registry for.</p> required <code>dek</code> <code>bytes</code> <p>The Data Encryption Key (DEK) to store in the SharedKeyRegistry table. The DEK is encrypted using the public key of each user before it is stored.</p> required Source code in <code>models/document.py</code> <pre><code>def update_shared_keys_registry(self, user_ids: list[str], dek: bytes):\n    \"\"\"\n    Updates the shared keys registry for the given users.\n\n    This function updates the SharedKeyRegistry table with the given user\n    IDs and the Data Encryption Key (DEK) for the document. The DEK is\n    encrypted using the public key of each user and stored in the\n    SharedKeyRegistry table.\n\n    Args:\n        user_ids (list[str]): A list of User IDs to update the shared\n            keys registry for.\n        dek (bytes): The Data Encryption Key (DEK) to store in the\n            SharedKeyRegistry table. The DEK is encrypted using the\n            public key of each user before it is stored.\n    \"\"\"\n    user_id_obj_map = User.get_id_obj_map(user_ids)\n    for user_id, user in user_id_obj_map.items():\n        shared_key = SharedKeyRegistry(\n            user_id=user_id,\n            document_id=str(self.id),\n            shared_key=RSA.encrypt_data(dek, user.public_key),\n        )\n        shared_key.upsert()\n</code></pre>"},{"location":"api/models/#models.document.DocumentBase","title":"<code>DocumentBase</code>","text":"<p>               Bases: <code>DocumentDownloadResponse</code></p> <p>Base model for creating new documents.</p> <p>This model is used to create new documents in the system. It contains the essential information required to create a document, such as the filepath and content of the document.</p> Source code in <code>models/document.py</code> <pre><code>class DocumentBase(DocumentDownloadResponse):\n    \"\"\"\n    Base model for creating new documents.\n\n    This model is used to create new documents in the system. It contains the\n    essential information required to create a document, such as the filepath\n    and content of the document.\n    \"\"\"\n    share_with: list[str] = Field(\n        default_factory=list, description=\"User IDs to give access to this document.\"\n    )\n</code></pre>"},{"location":"api/models/#models.document.DocumentCommon","title":"<code>DocumentCommon</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Common fields for Document and DocumentBase models.</p> <p>This class serves as a base for storing common attributes related to documents.  It provides a standardized way to define the essential properties required for  handling documents within the system. The attributes defined here are shared  among different document models to ensure consistency.</p> <p>Attributes:</p> Name Type Description <code>filepath</code> <code>str</code> <p>The filepath of the document. This is used to locate the  document in the storage system. The path is indexed to improve the  performance of queries that filter or sort based on the document's path.</p> <code>owner_id</code> <code>str</code> <p>The User ID of the owner of the document. This field  establishes an ownership link between the document and a user in the  system. It uses a foreign key reference to ensure that the owner_id  corresponds to a valid user in the database.</p> Source code in <code>models/document.py</code> <pre><code>class DocumentCommon(SQLModel):\n    \"\"\"\n    Common fields for Document and DocumentBase models.\n\n    This class serves as a base for storing common attributes related to documents. \n    It provides a standardized way to define the essential properties required for \n    handling documents within the system. The attributes defined here are shared \n    among different document models to ensure consistency.\n\n    Attributes:\n        filepath (str): The filepath of the document. This is used to locate the \n            document in the storage system. The path is indexed to improve the \n            performance of queries that filter or sort based on the document's path.\n\n        owner_id (str): The User ID of the owner of the document. This field \n            establishes an ownership link between the document and a user in the \n            system. It uses a foreign key reference to ensure that the owner_id \n            corresponds to a valid user in the database.\n    \"\"\"\n    filepath: str = Field(index=True, description=\"The filepath of the document\")\n    owner_id: str = Field(\n        foreign_key=\"user.id\", description=\"User ID of the Owner of the document\"\n    )\n</code></pre>"},{"location":"api/models/#models.document.DocumentDownloadResponse","title":"<code>DocumentDownloadResponse</code>","text":"<p>               Bases: <code>DocumentCommon</code></p> <p>Document download response model.</p> <p>This model is used to represent a document that is being downloaded from the server. It contains the filepath and content of the document.</p> Source code in <code>models/document.py</code> <pre><code>class DocumentDownloadResponse(DocumentCommon):\n    \"\"\"\n    Document download response model.\n\n    This model is used to represent a document that is being downloaded from the\n    server. It contains the filepath and content of the document.\n    \"\"\"\n    content: bytes = Field(description=\"The content of the document in bytes\")\n</code></pre>"},{"location":"api/models/#models.document.DocumentShareResponse","title":"<code>DocumentShareResponse</code>","text":"<p>               Bases: <code>DocumentCommon</code></p> <p>Document share response model.</p> <p>This model is used to represent a document that is being shared with another user.</p> Source code in <code>models/document.py</code> <pre><code>class DocumentShareResponse(DocumentCommon):\n    \"\"\"\n    Document share response model.\n\n    This model is used to represent a document that is being shared with another\n    user.\n    \"\"\"\n    id: str\n    owner_id: str\n    uploaded_on: datetime\n    shared_with: list[str] = Field(default_factory=list)\n    not_shared_with: list[str] = Field(default_factory=list)\n</code></pre>"},{"location":"api/models/#models.document.SharedKeyRegistry","title":"<code>SharedKeyRegistry</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Stores the shared encryption keys for a given document and user pair.</p> <p>The shared key is encrypted using the user's public key, and can be decrypted by the user using their private key. This allows the user to access the document without having to be re-shared the document.</p> <p>The shared key is stored in the database as a binary blob, and is encrypted using the user's public key. This means that only the user who the document is shared with can decrypt the shared key.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>The User ID of the user the document is shared with.</p> <code>document_id</code> <code>str</code> <p>The Document ID of the document that is shared.</p> <code>shared_key</code> <code>bytes</code> <p>The encrypted shared key.</p> <code>created_at</code> <code>datetime</code> <p>The timestamp when the shared key was created.</p> <code>document</code> <code>Document</code> <p>The document that is shared.</p> <code>user</code> <code>User</code> <p>The user that the document is shared with.</p> Source code in <code>models/document.py</code> <pre><code>class SharedKeyRegistry(SQLModel, table=True):\n    \"\"\"\n    Stores the shared encryption keys for a given document and user pair.\n\n    The shared key is encrypted using the user's public key, and can be decrypted\n    by the user using their private key. This allows the user to access the document\n    without having to be re-shared the document.\n\n    The shared key is stored in the database as a binary blob, and is encrypted\n    using the user's public key. This means that only the user who the document is\n    shared with can decrypt the shared key.\n\n    Attributes:\n        user_id (str): The User ID of the user the document is shared with.\n        document_id (str): The Document ID of the document that is shared.\n        shared_key (bytes): The encrypted shared key.\n        created_at (datetime): The timestamp when the shared key was created.\n        document (Document): The document that is shared.\n        user (User): The user that the document is shared with.\n    \"\"\"\n    user_id: str = Field(foreign_key=\"user.id\", primary_key=True, ondelete=\"CASCADE\")\n    document_id: str = Field(foreign_key=\"document.id\", primary_key=True, ondelete=\"CASCADE\")\n    shared_key: bytes\n    created_at: datetime = Field(default_factory=datetime.now)\n    document: \"Document\" = Relationship(back_populates=\"shared_keys\")\n    user: \"User\" = Relationship(back_populates=\"shared_keys\")\n</code></pre>"},{"location":"api/models/#modelsenums","title":"models.enums","text":""},{"location":"api/models/#models.enums","title":"<code>models.enums</code>","text":""},{"location":"api/models/#modelsuser","title":"models.user","text":""},{"location":"api/models/#models.user","title":"<code>models.user</code>","text":""},{"location":"api/models/#models.user.User","title":"<code>User</code>","text":"<p>               Bases: <code>UserBase</code></p> Source code in <code>models/user.py</code> <pre><code>class User(UserBase, table=True):\n    public_key: str\n    encrypted_private_key: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    # Many-to-many relationships via intermediary tables\n    teams: list[Team] = Relationship(back_populates=\"members\", link_model=UserTeamLink)\n    projects: list[Project] = Relationship(\n        back_populates=\"members\", link_model=UserProjectLink\n    )\n    shared_keys: list[\"SharedKeyRegistry\"] = Relationship(  # noqa: F821\n        back_populates=\"user\",\n        sa_relationship_kwargs={\"primaryjoin\": \"SharedKeyRegistry.user_id == User.id\"},\n        cascade_delete=True,\n    )\n\n    @classmethod\n    def from_base(cls, user: UserBase):\n        private_key, public_key = RSA.generate_key_pair(out_format=KeyFormat.STRING)\n        parmanent_password = generate_phrase(length=8, sep=\"-\", capitalize=False).passphrase\n        encrypted_private_key = AES(parmanent_password).encrypt(private_key.encode())\n\n        user_obj = cls(\n            id=user.id,\n            name=user.name,\n            email=user.email,\n            designation=user.designation,\n            public_key=public_key,\n            encrypted_private_key=encrypted_private_key.hex(),\n        ).create()\n\n        return UserCreateResponse(\n            id=user_obj.id,\n            name=user_obj.name,\n            email=user_obj.email,\n            designation=user_obj.designation,\n            parmanent_password=parmanent_password,\n        )\n\n    @classmethod\n    def get_id_obj_map(cls, user_ids: list[str]):\n        users = cls.get_by_ids(user_ids)\n        return {user.id: user for user in users}\n\n    def get_private_key(self, password: str):\n        return AES(password).decrypt(bytes.fromhex(self.encrypted_private_key)).decode()\n\n    def verify_private_key(self, password: str):\n        \"\"\"Verifies that the given private key matches the public key of the user. Returns True if the key is valid, False otherwise.\"\"\"\n        return RSA.verify_key_pair(self.get_private_key(password), self.public_key)\n\n    def verify_password(self, password: str):\n        return self.verify_private_key(password)\n</code></pre>"},{"location":"api/models/#models.user.User.verify_private_key","title":"<code>verify_private_key(password)</code>","text":"<p>Verifies that the given private key matches the public key of the user. Returns True if the key is valid, False otherwise.</p> Source code in <code>models/user.py</code> <pre><code>def verify_private_key(self, password: str):\n    \"\"\"Verifies that the given private key matches the public key of the user. Returns True if the key is valid, False otherwise.\"\"\"\n    return RSA.verify_key_pair(self.get_private_key(password), self.public_key)\n</code></pre>"},{"location":"api/root/","title":"Application Entry","text":""},{"location":"api/root/#config_1","title":"config","text":""},{"location":"api/root/#config","title":"<code>config</code>","text":"<p>Module for configuring the application's storage backends, JWT settings, and database connection.</p> <p>This module defines: - Configurable file storage backends (<code>DATA_STORE</code> and <code>DOCUMENT_STORE</code>) that can be set to any backend   supported by <code>backends.filesystem</code> (e.g., LocalFileSystem, S3). - JWT-related constants, such as the secret key, algorithm, and token expiration time. - The database connection URL (<code>DATABASE_URL</code>), which can support any database type compatible with SQLAlchemy. - A function to create and configure an SQLModel database engine (<code>getEngine</code>).</p> <p>Usage: - Modify the <code>DATA_STORE</code> and <code>DOCUMENT_STORE</code> to use different backends as needed. - Ensure the <code>JWT_SECRET_KEY</code> is securely managed. - Adjust the <code>DATABASE_URL</code> for different database types or deployment environments.</p> <p>Dependencies: - <code>sqlmodel</code> for database interaction. - <code>backends.filesystem</code> for file storage management.</p>"},{"location":"api/root/#config.DATABASE_URL","title":"<code>DATABASE_URL = 'sqlite:///' + (DATA_STORE.root / 'db.sqlite').as_posix()</code>  <code>module-attribute</code>","text":"<p>The connection URL for the database used by the application. This can be any database URL supported by SQLAlchemy, such as SQLite, PostgreSQL, MySQL, etc. Currently configured to use SQLite with the database file stored in the root of the data store as \"db.sqlite\".</p>"},{"location":"api/root/#config.DATA_STORE","title":"<code>DATA_STORE = LocalFileSystem('./data')</code>  <code>module-attribute</code>","text":"<p>An instance of a file storage backend used as the primary data store for the application. This can be configured to use any backend supported by <code>backends.filesystem</code>, such as LocalFileSystem, S3, or others. In this case, it is set to use LocalFileSystem with the root directory \"./data\".</p>"},{"location":"api/root/#config.DOCUMENT_STORE","title":"<code>DOCUMENT_STORE = LocalFileSystem('./data/documents')</code>  <code>module-attribute</code>","text":"<p>An instance of a file storage backend used specifically for document storage. This can use any backend supported by <code>backends.filesystem</code>, such as LocalFileSystem, S3, or others. Currently configured to use LocalFileSystem with the root directory \"./data/documents\".</p>"},{"location":"api/root/#config.JWT_ALGORITHM","title":"<code>JWT_ALGORITHM = 'HS256'</code>  <code>module-attribute</code>","text":"<p>The algorithm used for encoding and decoding JWTs. In this case, it uses the HS256 (HMAC with SHA-256) algorithm.</p>"},{"location":"api/root/#config.JWT_EXPIRE_MINUTES","title":"<code>JWT_EXPIRE_MINUTES = 30</code>  <code>module-attribute</code>","text":"<p>The expiration time (in minutes) for JWTs. Tokens will expire 30 minutes after being issued.</p>"},{"location":"api/root/#config.JWT_SECRET_KEY","title":"<code>JWT_SECRET_KEY = 'your-secret-key'</code>  <code>module-attribute</code>","text":"<p>The secret key used for signing and verifying JSON Web Tokens (JWT). Ensure this is kept secure and not exposed publicly.</p>"},{"location":"api/root/#config.getEngine","title":"<code>getEngine()</code>","text":"<p>Creates and returns an SQLModel database engine for interacting with the database.</p> <p>The engine is configured to: - Use the connection URL defined in <code>DATABASE_URL</code>. - Disable query echoing (for cleaner logs). - Include <code>check_same_thread=False</code> to ensure compatibility in a multi-threaded environment when using SQLite.</p> <p>Returns:</p> Name Type Description <code>Engine</code> <p>The SQLModel database engine.</p> Source code in <code>config.py</code> <pre><code>def getEngine():\n    \"\"\"\n    Creates and returns an SQLModel database engine for interacting with the database.\n\n    The engine is configured to:\n    - Use the connection URL defined in `DATABASE_URL`.\n    - Disable query echoing (for cleaner logs).\n    - Include `check_same_thread=False` to ensure compatibility in a multi-threaded environment when using SQLite.\n\n    Returns:\n        Engine: The SQLModel database engine.\n    \"\"\"\n    return create_engine(\n        DATABASE_URL, echo=False, connect_args={\"check_same_thread\": False}\n    )\n</code></pre>"},{"location":"api/root/#main_1","title":"main","text":""},{"location":"api/root/#main","title":"<code>main</code>","text":""}]}